{"version":3,"file":"main.1b2a2888cf3ed5fc0d13.js","mappings":"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","sources":["webpack:///webpack/runtime/chunk loaded","webpack:///./src/assets/example.png","webpack:///./src/ui/info.tsx","webpack:///./src/talents.ts","webpack:///./src/items.ts","webpack:///./src/ui/item-select.tsx","webpack:///./src/ui/factory-select.tsx","webpack:///./src/utils.ts","webpack:///./src/transfer-unit.ts","webpack:///./src/transfer-container.ts","webpack:///./src/industry.ts","webpack:///./src/container.ts","webpack:///./src/router.ts","webpack:///./src/graph.ts","webpack:///./src/generator.ts","webpack:///./src/serialize.ts","webpack:///./src/ui/factory-map.tsx","webpack:///./src/ui/render-factory.tsx","webpack:///./src/ui/transfer-container-instruction.tsx","webpack:///./src/ui/node-instruction.tsx","webpack:///./src/ui/merge-node-instruction.tsx","webpack:///./src/ui/ore-instruction.tsx","webpack:///./src/ui/generate-instructions.tsx","webpack:///./src/ui/factory-count.tsx","webpack:///./src/ui/factory.tsx","webpack:///./src/ui/set-talents.tsx","webpack:///./src/ui/set-ore-prices.tsx","webpack:///./src/ui/app.tsx","webpack:///./src/main.tsx","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/global","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///webpack/runtime/node module decorator","webpack:///webpack/runtime/publicPath","webpack:///webpack/runtime/jsonp chunk loading","webpack:///webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","export default __webpack_public_path__ + \"91c08251455a4e6c7a62de2887600d01.png\";","import * as React from \"react\"\nimport { Button } from \"antd\"\nimport { AppState } from \"./app\"\nconst example = require(\"../assets/example.png\")\n\n/**\n * Properties of the Info component\n */\nexport interface InfoProps {\n    /**\n     * Set the parent application state\n     * @param state the AppState\n     */\n    setAppState: (state: AppState) => void\n}\n\n/**\n * Info component\n * @param props {@link InfoProps}\n */\nexport function Info({ setAppState }: InfoProps) {\n    return (\n        <React.Fragment>\n            <Button onClick={() => setAppState(AppState.HOME)}>Back</Button>\n            <br />\n            <h2>About</h2>\n            This is a factory generator for&nbsp;\n            <a href=\"https://www.dualuniverse.game/\">Dual Universe</a>. Given a set of items to\n            build, this tool will determine a factory plan from raw ores to the final products. The\n            factory is designed to support the production rates of all intermediate industries.\n            Therefore, this is a factory plan that will maximize production efficiency even after\n            production interruptions. If you encouter any problems or would like to request new\n            features, please submit an{\" \"}\n            <a href=\"https://github.com/tvwenger/du-factory-generator/issues\">issue on Github</a>,\n            or <a href=\"https://discord.gg/gXSWKqVnHx\">join our Discord server</a>.\n            <h2>Instructions: Starting a new factory</h2>\n            <ul>\n                <li>\n                    Set your talents and, optionally, the current raw ore prices. Be sure to\n                    download these data in JSON format so that you can quickly set the data in the\n                    future.\n                </li>\n                <li>Click \"Start a New Factory.\"</li>\n                <li>\n                    Select all items that you would like to produce in the factory, then click\n                    \"Next.\"\n                </li>\n                <li>\n                    Enter the requested production rate of each item, as well as the quantity you\n                    would like to maintain in the output container(s), then click \"Next.\"\n                </li>\n                <li>\n                    Wait while your factory plan is generated. This can take a while (up to a few\n                    minutes) for large factories. Once complete, you will see a list of the required\n                    industries, containers, and schematics for your factory, as well as the raw ore\n                    values of the produced items.\n                </li>\n                <li>\n                    Click \"Factory Map\" to see an interactive schematic of the entire factory, which\n                    you can download in PNG format (low-resolution) or SVG format (high-resolution).\n                </li>\n                <li>\n                    Click \"Building Instructions\" to see a step-by-step plan to build the factory.\n                </li>\n                <li>\n                    Click \"Download Factory as JSON\" to save the factory to a file, which you can\n                    then use as a starting point for future additions to the factory.\n                </li>\n            </ul>\n            <b>Note:</b> You can also select the factory production list using a comma separated\n            values (CSV) file. Create a plain text file formatted like:\n            <pre>Item Name, Number Produced per Day, Maintain Value</pre>\n            For example:\n            <pre>\n                Container S, 10, 50\n                <br />\n                Container M, 10, 50\n                <br />\n                Container L, 2, 10\n            </pre>\n            <a href=\"https://raw.githubusercontent.com/tvwenger/du-factory-generator/master/item_list.csv\">\n                Here is a link\n            </a>\n            &nbsp;to a blank CSV file with all available item names.\n            <h2>Instructions: Starting from an existing factory</h2>\n            <ul>\n                <li>\n                    Set your talents and, optionally, the current raw ore prices. Be sure to\n                    download these data in JSON format so that you can quickly set the data in the\n                    future.\n                </li>\n                <li>Click \"Start From Existing Factory.\"</li>\n                <li>\n                    Upload the factory JSON file. Note that only JSON files for the current Factory\n                    Generator version are acceted, and your set talents must match or exceed those\n                    used to generate the original factory plan.\n                </li>\n                <li>\n                    You will be shown the current outputs of the factory. Select new items that you\n                    would like to produce in the factory, and add existing items if you would like\n                    to produce more of them, then click \"Next.\"\n                </li>\n                <li>\n                    Enter the requested production rate, as well as the additional quantity you\n                    would like to maintain in the output container(s), then click \"Next.\"\n                </li>\n                <li>Visualize and save the factory as before.</li>\n            </ul>\n            <h2>Factory Instruction Example</h2>\n            <img src={example.default} width=\"600px\" />\n            <ul>\n                <li>\n                    The text at the top of each row shows the item category and tier (e.g., \"Pure\n                    Tier 1\")\n                </li>\n                <li>The text above each group shows the produced item (e.g., \"Pure Aluminium\").</li>\n                <li>\n                    The leftmost arrows show the incoming links to the industries. Each link is\n                    named by the container contents (e.g., Hydrogen) and the identifier (e.g., \"C0\")\n                </li>\n                <li>\n                    The circles are industries, the diamonds are transfer units, and the text inside\n                    indicates the industry type (i.e., \"Che\" for \"Chemical Industry M\"). Multiple\n                    industries can output to a single container. The text above the circle (e.g.,\n                    \"P0\") is the identifier for the industry or transfer unit.\n                </li>\n                <li>\n                    The green text above the arrow (e.g., \"25/min\") is the production rate of all\n                    industries and the output rate of all transfer units outputing to the container.\n                </li>\n                <li>\n                    The squares show the containers, and the text inside indicates the required\n                    container size (i.e., \"L\" for \"Container L\"). Some outputs may require multiple\n                    containers connected via a Container Hub (e.g., \"XL+M\" requires a \"Container XL\"\n                    and \"Container M\" connected via a \"Container Hub\"). The text above the square\n                    (e.g., D0) is the indentifier for the container. The text below the square is\n                    the required maintain value.\n                </li>\n                <li>\n                    The red text above the arrow (e.g., \"12/day\") is the maximum consumption rate of\n                    all industries or transfer units consuming from the container. This maximum\n                    consumption rate is achieved when the factory is started or re-started after an\n                    interruption. The factory is designed to support this maximum consumption rate.\n                </li>\n                <li>\n                    The blue text below the arrow is the \"steady state\" consumption rate of all\n                    industries or transfer units consuming from the container. This steady state\n                    consumption rate is achieved some time after the factory is started or\n                    re-started.\n                </li>\n                <li>\n                    The rightmost arrows show the consumers from the container. Each link is named\n                    by the produced item (e.g., \"Aluminium\") and the identifier (e.g., \"P0\").\n                </li>\n                <li>\n                    <b>Dashed Arrows and Labels:</b> Dashed arrows indicate byproducts that are\n                    transfered out via the labeled transfer units.\n                </li>\n                <li>\n                    <b>Blue Boxes and Text:</b> A blue border around a container represents a\n                    factory \"output\". This is an item that you requested your factory to produce.\n                </li>\n                <li>\n                    <b>Filled Circles and Boxes:</b> When you start from an existing factory, some\n                    industries, transfer units, and containers will be filled. This is to highlight\n                    new entities or entities that have been changed from the existing factory. No\n                    existing links are removed, but there may be new industries, new links, a\n                    different maintain amount, or a different container size.\n                </li>\n                <li>\n                    <b>Transfer Containers:</b> Some recipes require more than seven ingredients\n                    (the industry incoming link limit). In this case, there will be a transfer\n                    container that holds more than one item type and is fed by transfer units. The\n                    maintain value for each item is shown to the bottom-right of each transfer unit.\n                </li>\n            </ul>\n        </React.Fragment>\n    )\n}\n","import { Category, Tier } from \"./items\"\n\nexport enum TalentType {\n    TIME = \"Time\",\n    INPUT = \"Input\",\n    OUTPUT = \"Output\",\n}\n\nexport enum TalentSubject {\n    TIER = \"Tier\",\n    ITEM = \"Item\",\n    INDUSTRY = \"Industry\",\n    TYPE = \"Type\",\n}\n\nexport enum TalentGroup {\n    PURES = \"Pures\",\n    PRODUCTS = \"Products\",\n    PARTS = \"Parts\",\n    ELEMENTS = \"Elements\",\n    AMMUNITION = \"Ammunition\",\n    FUELS = \"Fuels\",\n    PURE_HONECOMBS = \"Pure Honeycombs\",\n    PRODUCT_HONEYCOMBS = \"Product Honeycombs\",\n    SCRAPS = \"Scraps\",\n    INDUSTRY = \"Industry\",\n}\n\n/**\n * Talent type definition\n */\nexport interface Talent {\n    readonly name: string\n    readonly skillGroup: string\n    readonly talentGroup: TalentGroup\n    readonly type: TalentType\n    readonly subject: TalentSubject\n    readonly modifier: number\n    readonly target: string | undefined\n    readonly targetCategory: Category\n    readonly targetTier: Tier\n}\n\n/**\n * Returns a new Talent\n * @param name talent name\n * @param skillGroup skill's group name\n * @param talentGroup skill's talent group\n * @param type talent type\n * @param subject entity to which this talent applies\n * @param modifier modifier amount (percentage)\n * @param target talent's applicable item\n * @param targetCategory talent's applicable category\n * @param targetTier talent's applicable tier\n */\nexport function talent(\n    name: string,\n    skillGroup: string,\n    talentGroup: TalentGroup,\n    type: TalentType,\n    subject: TalentSubject,\n    modifier: number,\n    target: string,\n    targetCategory: Category,\n    targetTier: Tier,\n): Talent {\n    return {\n        name,\n        skillGroup,\n        talentGroup,\n        type,\n        subject,\n        modifier,\n        target,\n        targetCategory,\n        targetTier,\n    }\n}\n\n/**\n * Load talent data\n */\nvar talents: { [key: string]: Talent } = {}\nvar data = require(\"./data/talents.json\")\nfor (const outer of data) {\n    for (const inner of outer.data) {\n        for (const skill of inner.skills) {\n            const name = inner.name + \": \" + skill.name\n            talents[name] = talent(\n                name,\n                inner.name,\n                outer.name,\n                skill.class !== undefined ? skill.class : inner.class,\n                skill.subject !== undefined ? skill.subject : inner.subject,\n                skill.amount !== undefined ? skill.amount : inner.amount,\n                skill.name !== undefined ? skill.name : inner.name,\n                skill.type !== undefined ? skill.type : inner.type,\n                skill.tier !== undefined ? skill.tier : inner.tier,\n            )\n        }\n    }\n}\n// Validate\nfor (const [name, talent] of Object.entries(talents)) {\n    if (!Object.values(TalentType).includes(talent.type)) {\n        throw new Error(\"Invalid talent type \" + talent.type)\n    }\n    if (!Object.values(TalentSubject).includes(talent.subject)) {\n        throw new Error(\"Invalid talent subject \" + talent.subject)\n    }\n    if (!Object.values(TalentGroup).includes(talent.talentGroup)) {\n        throw new Error(\"Invalid talent group \" + talent.talentGroup)\n    }\n}\nexport const TALENTS = talents\n","import Item from \"antd/lib/list/Item\"\nimport { ItemRender } from \"antd/lib/upload/interface\"\nimport { TALENTS, TalentSubject, TalentType } from \"./talents\"\n\nexport type Liter = number\nexport type Seconds = number\nexport type Quantity = number\n\nexport enum Tier {\n    GAS = 0,\n    BASIC = 1,\n    UNCOMMON = 2,\n    ADVANCED = 3,\n    RARE = 4,\n    EXOTIC = 5,\n}\n\nexport enum Category {\n    AMMO = \"Ammo\",\n    CATALYST = \"Catalyst\",\n    COMBAT_ELEMENT = \"Combat Element\",\n    COMPLEX_PART = \"Complex Part\",\n    EXCEPTIONAL_PART = \"Exceptional Part\",\n    FUEL = \"Fuel\",\n    FUNCTIONAL_PART = \"Functional Part\",\n    FURNITURE_AND_APPLIANCES_ELEMENT = \"Furniture & Appliances Element\",\n    INDUSTRY_AND_INFRASTRUCTURE_ELEMENT = \"Industry & Infrastructure Element\",\n    INTERMEDIARY_PART = \"Intermediary Part\",\n    ORE = \"Ore\",\n    PILOTING_ELEMENT = \"Piloting Element\",\n    PLANET_ELEMENT = \"Planet Element\",\n    PRODUCT = \"Product\",\n    PRODUCT_HONEYCOMB = \"Product Honeycomb\",\n    PURE = \"Pure\",\n    PURE_HONEYCOMB = \"Pure Honeycomb\",\n    SCRAP = \"Scrap\",\n    STRUCTURAL_PART = \"Structural Part\",\n    SYSTEMS_ELEMENT = \"Systems Element\",\n    WARP_CELLS = \"Warp Cells\",\n}\n\n/**\n * Item type definition\n */\nexport interface Item {\n    readonly name: string\n    readonly tier: Tier\n    readonly category: Category\n    readonly volume: Liter\n    readonly transferBatchSize: Quantity\n    readonly transferTime: Seconds\n}\n\n/**\n * Ore type guard\n * @param item Item to check\n */\nexport function isOre(item: Item): boolean {\n    return item.category === Category.ORE\n}\n\n/**\n * Gas type guard\n * @param item Item to check\n */\nexport function isGas(item: Item): boolean {\n    return item.tier === Tier.GAS\n}\n\n/**\n * Craftable type guard\n * @param item Item to check\n */\nexport function isCraftable(item: Item): boolean {\n    return !isOre(item)\n}\n\n/**\n * Catalyst type guard\n * @param item Item to check\n */\nexport function isCatalyst(item: Item): boolean {\n    return item.category === Category.CATALYST\n}\n\n/**\n * Returns a new Item\n * @param name Name\n * @param tier Tier\n * @param category Category\n * @param volume Volume (L)\n * @param transferBatchSize Transfer Unit batch size\n * @param transferTime Transfer Unit transfer time (s)\n */\nexport function item(\n    name: string,\n    tier: Tier,\n    category: Category,\n    volume: Liter,\n    transferBatchSize: Quantity,\n    transferTime: Seconds,\n): Item {\n    return {\n        name,\n        tier,\n        category,\n        volume,\n        transferBatchSize,\n        transferTime,\n    }\n}\n\n/**\n * Recipe type definition\n */\nexport interface Recipe {\n    readonly item: Item\n    readonly quantity: Quantity\n    readonly time: Seconds\n    readonly industry: string\n    readonly byproducts: Map<Item, Quantity>\n    readonly ingredients: Map<Item, Quantity>\n}\n\n/**\n * Returns a new Recipe\n * @param item Item\n * @param quantity Production quantity\n * @param time Production time (s)\n * @param industry Required industry\n * @param byproducts Byproducts and quantities\n * @param ingredients Ingredients and quantities\n */\nexport function recipe(\n    item: Item,\n    quantity: Quantity,\n    time: Seconds,\n    industry: string,\n    byproducts: Map<Item, Quantity>,\n    ingredients: Map<Item, Quantity>,\n): Recipe {\n    return {\n        item,\n        quantity,\n        time,\n        industry,\n        byproducts,\n        ingredients,\n    }\n}\n\n/**\n * Load item data, populate ITEMS and RECIPES\n */\nvar items: { [key: string]: Item } = {}\nvar recipes: { [key: string]: Recipe } = {}\nvar data = require(\"./data/recipes.json\")\nfor (const name in data) {\n    // Most items have transfer batch size = 1 and\n    // transfer time [seconds] = volume [liters]\n    var transferBatchSize = 1\n    var transferTime = data[name].volume\n    if (data[name].type === Category.SCRAP) {\n        transferBatchSize = 200\n        transferTime = 200\n    } else if (data[name].type === Category.FUEL) {\n        transferBatchSize = 100\n        transferTime = 11\n    } else if (data[name].type == Category.PURE_HONEYCOMB) {\n        transferBatchSize = 100\n        transferTime = 11\n    } else if (data[name].type == Category.PRODUCT_HONEYCOMB) {\n        transferBatchSize = 100\n        transferTime = 11\n    } else if (data[name].type == Category.ORE) {\n        transferBatchSize = 100\n        transferTime = 11\n    } else if (data[name].type == Category.CATALYST) {\n        transferBatchSize = 1\n        transferTime = 11\n    } else if (data[name].type == Category.PRODUCT) {\n        transferBatchSize = 100\n        transferTime = 11\n    } else if (data[name].type == Category.PURE) {\n        transferBatchSize = 100\n        transferTime = 11\n    } else if (data[name].type == Category.COMPLEX_PART) {\n        transferBatchSize = 50\n        transferTime = 50 * data[name].volume\n    } else if (data[name].type == Category.INTERMEDIARY_PART) {\n        transferBatchSize = 200\n        transferTime = 200 * data[name].volume\n    }\n    items[name] = item(\n        name,\n        data[name].tier,\n        data[name].type,\n        data[name].volume,\n        transferBatchSize,\n        transferTime,\n    )\n}\nfor (const name in data) {\n    let byproducts: Map<Item, Quantity> = new Map()\n    for (const [byproduct, quantity] of Object.entries(data[name].byproducts)) {\n        byproducts.set(items[byproduct], quantity as Quantity)\n    }\n    let ingredients: Map<Item, Quantity> = new Map()\n    for (const [ingredient, quantity] of Object.entries(data[name].input)) {\n        ingredients.set(items[ingredient], quantity as Quantity)\n    }\n    recipes[name] = recipe(\n        items[name],\n        data[name].outputQuantity,\n        data[name].time,\n        data[name].industry,\n        byproducts,\n        ingredients,\n    )\n}\n// Validate\nfor (const [name, item] of Object.entries(items)) {\n    if (!Object.values(Tier).includes(item.tier)) {\n        throw new Error(\"Invalid item tier\" + item.tier)\n    }\n    if (!Object.values(Category).includes(item.category)) {\n        throw new Error(\"Invalid item category\" + item.category)\n    }\n}\n\nexport const ITEMS = items\nconst RECIPES = recipes\n\n/**\n * Get recipe for an item, and apply talents\n * @param item Item\n * @param talentLevels Talents\n */\nexport function getRecipe(item: Item, talentLevels: { [key: string]: number }) {\n    const oldRecipe = RECIPES[item.name]\n    let time_mod = 0\n    let input_mod = 0\n    let output_mod = 0\n\n    for (const [name, level] of Object.entries(talentLevels)) {\n        const talent = TALENTS[name]\n        let applicable = false\n        // Check industry talent\n        if (talent.subject === TalentSubject.INDUSTRY && talent.target === oldRecipe.industry) {\n            applicable = true\n        }\n        // Check specific item talent\n        else if (talent.subject === TalentSubject.ITEM && talent.target === item.name) {\n            applicable = true\n        }\n        // Check category\n        else if (talent.subject === TalentSubject.TYPE && talent.targetCategory === item.category) {\n            applicable = true\n        }\n        // Check category & tier talent\n        else if (\n            talent.subject === TalentSubject.TIER &&\n            talent.targetTier === item.tier &&\n            talent.targetCategory === item.category\n        ) {\n            applicable = true\n        }\n\n        if (applicable) {\n            if (talent.type === TalentType.TIME) {\n                time_mod += level * talent.modifier\n            } else if (talent.type === TalentType.INPUT) {\n                input_mod += level * talent.modifier\n            } else if (talent.type === TalentType.OUTPUT) {\n                output_mod += level * talent.modifier\n            }\n        }\n    }\n\n    // Create and return modified recipe\n    const quantity = oldRecipe.quantity * (1.0 + output_mod)\n    const time = oldRecipe.time * (1.0 - time_mod)\n    const ingredients: Map<Item, number> = new Map()\n    for (const [key, value] of oldRecipe.ingredients.entries()) {\n        ingredients.set(key, value * (1.0 - input_mod))\n    }\n    const byproducts: Map<Item, number> = new Map()\n    for (const [key, value] of oldRecipe.byproducts.entries()) {\n        byproducts.set(key, value * (1.0 + output_mod))\n    }\n    const newRecipe = recipe(item, quantity, time, oldRecipe.industry, byproducts, ingredients)\n    return newRecipe\n}\n\n/**\n * Containers sorted by capacity from smallest to largest\n */\nexport interface ContainerCapacity {\n    name: string\n    capacity: Liter\n}\nfunction containerCapacity(name: string, capacity: Liter): ContainerCapacity {\n    return {\n        name,\n        capacity,\n    }\n}\nexport const CONTAINERS_ASCENDING_BY_CAPACITY: ContainerCapacity[] = [\n    containerCapacity(\"Container XS\", 1000),\n    containerCapacity(\"Container S\", 8000),\n    containerCapacity(\"Container M\", 64000),\n    containerCapacity(\"Container L\", 128000),\n    containerCapacity(\"Container XL\", 256000),\n    containerCapacity(\"Expanded Container XL\", 512000),\n]\n\n/**\n * Get catalysts\n */\nexport const CATALYSTS = Object.values(ITEMS).filter(isCatalyst)\n\n/**\n * Return the required raw ore quantities needed to craft an item\n */\nexport function getRequiredOres(\n    item: Item,\n    requiredOres: { [key: string]: { [key: string]: number } },\n    talentLevels: { [key: string]: number },\n) {\n    const ores: { [key: string]: number } = {}\n\n    // Skip gas and catalyst\n    if (isGas(item) || isCatalyst(item)) {\n        return ores\n    }\n\n    // Loop over ingredients\n    const recipe = getRecipe(item, talentLevels)\n    const batchSize = recipe.quantity\n    for (const [ingredient, ingredientQuantity] of recipe.ingredients) {\n        // catch empty ingredients\n        if (ingredient === undefined) {\n            continue\n        }\n\n        if (isOre(ingredient)) {\n            // If this ingredient is ore, add the quantity\n            if (ores[ingredient.name] === undefined) {\n                ores[ingredient.name] = 0\n            }\n            ores[ingredient.name] += ingredientQuantity / batchSize\n        } else {\n            // Use already calculated values if possible\n            let ingredientOres = requiredOres[ingredient.name]\n            if (ingredientOres === undefined) {\n                // Recursively call this function\n                ingredientOres = getRequiredOres(ingredient, requiredOres, talentLevels)\n                requiredOres[ingredient.name] = ingredientOres\n            }\n            for (const [ore, oreQuantity] of Object.entries(requiredOres[ingredient.name])) {\n                if (ores[ore] === undefined) {\n                    ores[ore] = 0\n                }\n                ores[ore] += (oreQuantity * ingredientQuantity) / batchSize\n            }\n        }\n    }\n    return ores\n}\n","import { Item } from \"../items\"\nimport * as React from \"react\"\nimport { useMemo } from \"react\"\nimport { compose, groupBy, indexBy, prop, toPairs } from \"ramda\"\nimport { TreeSelect } from \"antd\"\n\n/**\n * Properties of the {@link ItemSelect} component\n */\nexport interface ItemSelectProps<T extends Item> {\n    /**\n     * All selectable items\n     */\n    items: T[]\n\n    /**\n     * The currently selected items\n     */\n    value: T[]\n\n    /**\n     * Callback function when the selection changes\n     * @param selection\n     */\n    onChange: (selection: T[]) => void\n}\n\n/**\n * Tree select component for selecting items.\n * @param props {@link ItemSelectProps}\n */\nexport function ItemSelect<T extends Item>(props: ItemSelectProps<T>) {\n    const treeData = useItemTreeData(props.items)\n    const [value, fromValue] = useItemSelection(props.items, props.value)\n\n    return (\n        <TreeSelect\n            style={{ width: \"100%\" }}\n            value={value}\n            dropdownStyle={{ maxHeight: 400, overflow: \"auto\" }}\n            treeData={treeData}\n            placeholder=\"Please select\"\n            multiple\n            allowClear\n            showArrow\n            treeCheckable\n            onChange={compose(props.onChange, fromValue)}\n        />\n    )\n}\n\n/**\n * Hook for grouping items into a tree based on their category for the use in {@link TreeSelect}\n * @param items all items to group\n */\nfunction useItemTreeData<T extends Item>(items: T[]) {\n    return useMemo(() => {\n        const byCategory = groupBy(prop(\"category\"), items)\n\n        return toPairs(byCategory).map(([category, items]) => ({\n            title: category,\n            value: category,\n            children: items.map((item) => ({\n                title: item.name,\n                value: item.name,\n            })),\n        }))\n    }, [items])\n}\n\n/**\n * Hook for mapping a selection of items to strings and back\n * @param items All selectable items\n * @param selection The currently selected items\n */\nfunction useItemSelection<T extends Item>(items: T[], selection: T[]) {\n    const byName = useMemo(() => indexBy(prop(\"name\"), items), [items])\n\n    const value = useMemo(() => selection.map(prop(\"name\")), [selection])\n\n    const fromValue = (itemNames: string[]) =>\n        itemNames.map((itemName) => byName[itemName]).filter((item) => item !== undefined)\n\n    return [value, fromValue] as const\n}\n","import * as React from \"react\"\nimport { Button, Upload, Divider } from \"antd\"\nimport { ItemSelect } from \"./item-select\"\nimport { FactoryState } from \"./factory\"\nimport { Item } from \"../items\"\n\n/**\n * Properties of the FactorySelect component\n */\ninterface FactorySelectProps {\n    /**\n     * Set the parent NewFactory state\n     * @param state parent component state\n     */\n    setFactoryState: (state: FactoryState) => void\n\n    // all craftable items\n    items: Item[]\n\n    // items to craft\n    selection: Item[]\n\n    /**\n     * Set the selection of items to craft\n     * @param selection items to craft\n     */\n    setSelection: (selection: Item[]) => void\n\n    /**\n     * Set the production rate and maintain value\n     */\n    setProductionRate: React.Dispatch<React.SetStateAction<{ [key: string]: number }>>\n    setMaintainValue: React.Dispatch<React.SetStateAction<{ [key: string]: number }>>\n}\n\n/**\n * Factory select elements to build component\n * @param props {@link FactorySelectProps}\n */\nexport function FactorySelect(props: FactorySelectProps) {\n    return (\n        <React.Fragment>\n            <h2>Select Items to Build</h2>\n            <Divider orientation=\"left\">Instructions</Divider>\n            <ul>\n                <li>Start typing the item name to filter</li>\n                <li>\n                    Or, upload a CSV file formatted like:{\" \"}\n                    <pre>\n                        Item Name, Number to produce per day, Number to maintain in output contanier\n                    </pre>\n                </li>\n            </ul>\n            <Divider orientation=\"left\">Upload</Divider>\n            <Upload\n                accept=\".csv\"\n                showUploadList={false}\n                beforeUpload={(file) => {\n                    const reader = new FileReader()\n                    reader.onload = () => {\n                        const result = reader.result as string\n                        const lines = result.split(\"\\n\")\n                        const myItems: Item[] = []\n                        for (const line of lines) {\n                            const parts = line.split(\",\")\n                            if (\n                                parts[0].trim() === \"\" ||\n                                parts[1].trim() === \"\" ||\n                                parts[2].trim() === \"\"\n                            ) {\n                                continue\n                            }\n                            const item = props.items.find(\n                                (element) => element.name === parts[0].trim(),\n                            )\n                            if (item === undefined) {\n                                console.log(\"Item \" + parts[0].trim() + \"not found\")\n                                continue\n                            }\n                            myItems.push(item)\n                            props.setProductionRate((prevState: { [key: string]: number }) => ({\n                                ...prevState,\n                                [item.name]: Number(parts[1].trim()) / (24 * 3600),\n                            }))\n                            props.setMaintainValue((prevState: { [key: string]: number }) => ({\n                                ...prevState,\n                                [item.name]: Number(parts[2].trim()),\n                            }))\n                        }\n                        props.setSelection(myItems)\n                        props.setFactoryState(FactoryState.COUNT)\n                    }\n                    reader.readAsText(file)\n                    // skip upload\n                    return false\n                }}\n            >\n                <Button>Upload CSV</Button>\n            </Upload>\n            <Divider orientation=\"left\">Select Items</Divider>\n            <ItemSelect items={props.items} value={props.selection} onChange={props.setSelection} />\n            <br />\n            <br />\n            <Button\n                type=\"primary\"\n                onClick={() => {\n                    if (props.selection.length > 0) {\n                        props.setFactoryState(FactoryState.COUNT)\n                    }\n                }}\n            >\n                Next\n            </Button>\n        </React.Fragment>\n    )\n}\n","import { Container } from \"./container\"\nimport { FactoryGraph, isProductionNode, MAX_CONTAINER_LINKS } from \"./graph\"\nimport { Industry } from \"./industry\"\nimport { isOre } from \"./items\"\nimport { TransferContainer } from \"./transfer-container\"\nimport {\n    isByproductTransferUnit,\n    isCatalystBalancer,\n    isTransferUnit,\n    TransferUnit,\n} from \"./transfer-unit\"\n\nexport type FactoryElement = Container | TransferContainer | Industry | TransferUnit\n\n/**\n * Shorten an item name to support the element name length in game\n * @param name Original name\n */\nexport function shortenName(name: string): string {\n    name = name.replace(\"Uncommon\", \"Unc\")\n    name = name.replace(\"Advanced\", \"Adv\")\n    name = name.replace(\"Anti-Matter\", \"AntiM\")\n    name = name.replace(\"Anti-Gravity\", \"AntiG\")\n    name = name.replace(\"-\", \"\")\n    return name\n}\n\n/**\n * Run some sanity checks on the factory\n * @param factory the factory graph\n */\nexport function sanityCheck(factory: FactoryGraph) {\n    // delta to avoid rounding errors\n    const delta = 1.0e-8\n\n    // Check that no containers exceed link limits\n    for (const container of factory.containers) {\n        if (container.incomingLinkCount > MAX_CONTAINER_LINKS) {\n            console.log(container)\n            throw new Error(\"Container exceeds incoming link limit\")\n        }\n        if (container.outgoingLinkCount > MAX_CONTAINER_LINKS) {\n            console.log(container)\n            throw new Error(\"Container exceeds outgoing link limit\")\n        }\n    }\n    for (const container of factory.transferContainers) {\n        if (container.incomingLinkCount > MAX_CONTAINER_LINKS) {\n            console.log(container)\n            throw new Error(\"TransferContainer exceeds incoming link limit\")\n        }\n        if (container.outgoingLinkCount > MAX_CONTAINER_LINKS) {\n            console.log(container)\n            throw new Error(\"TransferContainer exceeds outgoing link limit\")\n        }\n    }\n\n    // Check that the egress of each container is satisfied\n    for (const container of factory.containers) {\n        if (isOre(container.item)) {\n            continue\n        }\n        if (container.egress(container.item) > container.ingress(container.item) + delta) {\n            console.log(container)\n            console.log(\"Egress: \" + container.egress(container.item))\n            console.log(\"Ingress: \" + container.ingress(container.item))\n            throw new Error(\"Container egress exceeds ingress\")\n        }\n    }\n    for (const container of factory.transferContainers) {\n        for (const item of container.items) {\n            if (container.egress(item) > container.ingress(item) + delta) {\n                console.log(container)\n                console.log(\"Egress: \" + container.egress(item))\n                console.log(\"Ingress: \" + container.ingress(item))\n                throw new Error(\"Container egress exceeds ingress\")\n            }\n        }\n    }\n\n    // Check that required transfer rate is satisfied\n    for (const transferUnit of factory.transferUnits) {\n        // skip ore transfer units\n        if (isOre(transferUnit.item)) {\n            continue\n        }\n\n        // get actual transfer rate\n        let transferRate = 0.0\n        for (const [container, rate] of transferUnit.transferRates) {\n            transferRate += rate\n        }\n        if (transferUnit.requiredTransferRate - transferRate > delta) {\n            console.log(transferUnit)\n            console.log(\"Required transfer rate: \" + transferUnit.requiredTransferRate)\n            console.log(\"Actual transfer rate: \" + transferRate)\n            throw new Error(\"Transfer Unit required transfer rate not satisfied\")\n        }\n    }\n}\n\n/**\n * Merge dump and relay containers where possible\n * @param factory the factory graph\n */\nexport function mergeFactory(factory: FactoryGraph) {\n    for (const node of factory.nodes.values()) {\n        if (!isProductionNode(node)) {\n            // Remove ore node transfer unit\n            const containerChanged = node.relayRoutes[0].container.changed\n            node.relayRoutes[0].transferUnit.merged = true\n            node.relayRoutes[0].container.removeProducer(node.relayRoutes[0].transferUnit)\n            node.relayRoutes[0].container.changed = containerChanged\n            continue\n        }\n\n        // Check the transfer unit of each relay route.\n        for (const relayRoute of node.relayRoutes) {\n            // If this relay route is fed by only a single dump route,\n            // and if that dump route only feeds this relay route, then we can\n            // merge\n            const dumpRoutes = node.dumpRoutes.filter((dumpRoute) =>\n                dumpRoute.relayRoutes.includes(relayRoute),\n            )\n\n            if (dumpRoutes.length === 1 && dumpRoutes[0].relayRoutes.length === 1) {\n                const dumpContainer = dumpRoutes[0].container\n                const relayContainer = relayRoute.container\n                const transferUnit = relayRoute.transferUnit\n\n                // Check that relayContainer can support all of the dumpContainer's\n                // incoming links (-1, since the relay container will no longer have\n                // the merged transfer unit)\n                if (!relayContainer.canAddIncomingLinks(dumpContainer.incomingLinkCount - 1)) {\n                    continue\n                }\n\n                // Check that relayContainer can support all of the dumpContainer's\n                // outgoing links (-1, since we are excluding the merged transfer unit)\n                if (!relayContainer.canAddOutgoingLinks(dumpContainer.outgoingLinkCount - 1)) {\n                    continue\n                }\n\n                // do not count merging as a change\n                const relayContainerChanged = relayContainer.changed\n\n                // remove transfer unit producer and consumer\n                relayContainer.removeProducer(transferUnit)\n                dumpContainer.removeConsumer(transferUnit)\n\n                // Take all inputs to the dump container and route them to the relay container\n                for (const producer of dumpContainer.producers) {\n                    const producerChanged = producer.changed\n                    dumpContainer.removeProducer(producer)\n                    producer.setOutput(relayContainer)\n                    producer.changed = producerChanged\n                }\n                // Take all outputs from the dump container and route them to the relay container\n                for (const consumer of dumpContainer.consumers) {\n                    const consumerChanged = consumer.changed\n                    consumer.removeInput(dumpContainer)\n                    consumer.addInput(relayContainer)\n                    consumer.changed = consumerChanged\n                }\n                relayContainer.changed = relayContainerChanged\n\n                // flag dump container and transfer unit as merged\n                dumpContainer.merged = true\n                transferUnit.merged = true\n            }\n        }\n    }\n}\n\n/**\n * Unmerge dump and relay containers where possible\n * @param factory the factory graph\n */\nexport function unmergeFactory(factory: FactoryGraph) {\n    for (const node of factory.nodes.values()) {\n        if (!isProductionNode(node)) {\n            // Unmerge ore transfer unit\n            node.relayRoutes[0].transferUnit.merged = false\n            node.relayRoutes[0].container.addProducer(node.relayRoutes[0].transferUnit)\n            node.relayRoutes[0].container.changed = false\n            continue\n        }\n\n        // Check the transfer unit of each relay route.\n        for (const relayRoute of node.relayRoutes) {\n            if (!relayRoute.transferUnit.merged) {\n                continue\n            }\n\n            const dumpRoutes = node.dumpRoutes.filter((dumpRoute) =>\n                dumpRoute.relayRoutes.includes(relayRoute),\n            )\n\n            if (dumpRoutes.length !== 1) {\n                console.log(node)\n                throw new Error(\"Merged node has more than one dump route\")\n            }\n\n            const dumpContainer = dumpRoutes[0].container\n            const relayContainer = relayRoute.container\n            const transferUnit = relayRoute.transferUnit\n\n            // move all producers except transfer unit from relay container to dump container\n            for (const producer of relayContainer.producers) {\n                if (producer === transferUnit) {\n                    continue\n                }\n                relayContainer.removeProducer(producer)\n                producer.setOutput(dumpContainer)\n                producer.changed = false\n            }\n\n            // move all byproduct consumers to dump container\n            for (const consumer of relayContainer.consumers) {\n                if (\n                    isTransferUnit(consumer) &&\n                    (isByproductTransferUnit(consumer) || isCatalystBalancer(consumer))\n                ) {\n                    consumer.removeInput(relayContainer)\n                    consumer.addInput(dumpContainer)\n                    consumer.changed = false\n                }\n            }\n\n            // add transfer unit\n            transferUnit.addInput(dumpContainer)\n\n            relayContainer.changed = false\n            dumpContainer.changed = false\n            transferUnit.changed = false\n\n            dumpContainer.merged = false\n            transferUnit.merged = false\n        }\n    }\n}\n","import { Container, isContainer } from \"./container\"\nimport { MAX_INDUSTRY_LINKS, PerSecond } from \"./graph\"\nimport { Industry } from \"./industry\"\nimport { Item } from \"./items\"\nimport { TransferContainer } from \"./transfer-container\"\nimport { shortenName } from \"./utils\"\n\n/**\n * TransferUnits take an item from several inputs and deposit them into a single\n * output.\n */\nexport class TransferUnit {\n    inputs: Set<Container> = new Set()\n    output: Container | TransferContainer\n    // the required transfer rate\n    requiredTransferRate = 0.0\n    // the transfer rate from each input\n    transferRates: Map<Container, PerSecond> = new Map()\n    // if this element has changed\n    changed = true\n    // flag if this transferUnit is not necessary because the containers are merged\n    merged = false\n\n    /**\n     * Create a new TransferUnit\n     * @param id Identifier\n     * @param item Item to move\n     * @param output Output container\n     */\n    constructor(readonly id: string, readonly item: Item, output: Container | TransferContainer) {\n        this.output = output\n        output.addProducer(this)\n    }\n\n    /**\n     * Get this element's name\n     */\n    get name(): string {\n        return `${shortenName(this.item.name)} ${this.id}`\n    }\n\n    /**\n     * Remove an input container\n     * @param node Input container to remove\n     */\n    removeInput(node: Container) {\n        this.inputs.delete(node)\n        node.removeConsumer(this)\n        this.changed = true\n        node.changed = true\n    }\n\n    /**\n     * Add an input to this TransferUnit\n     * @param node input container to add\n     */\n    addInput(node: Container) {\n        this.inputs.add(node)\n        node.addConsumer(this)\n        this.changed = true\n        node.changed = true\n\n        if (!this.transferRates.has(node)) {\n            this.transferRates.set(node, 0.0)\n        }\n    }\n\n    /**\n     * Set the output container\n     * @param node Output container\n     */\n    setOutput(node: Container | TransferContainer) {\n        this.output = node\n        node.addProducer(this)\n        this.changed = true\n        node.changed = true\n    }\n\n    /**\n     * Count the number of input containers\n     */\n    get incomingLinkCount(): number {\n        return this.inputs.size\n    }\n\n    /**\n     * Check if we can add one more input container\n     */\n    get canAddIncomingLink(): boolean {\n        return this.incomingLinkCount < MAX_INDUSTRY_LINKS\n    }\n\n    /**\n     * Increase the required transfer rate\n     * @param rate transfer rate increase\n     */\n    increaseRequiredTransferRate(rate: PerSecond) {\n        this.requiredTransferRate += rate\n    }\n\n    /**\n     * Decrease the required transfer rate\n     * @param rate transfer rate increase\n     */\n    decreaseRequiredTransferRate(rate: PerSecond) {\n        this.requiredTransferRate -= rate\n    }\n\n    /**\n     * Set the transfer rate from a given container\n     * @param container container\n     * @param rate new transfer rate\n     */\n    setTransferRate(container: Container, rate: PerSecond) {\n        this.transferRates.set(container, rate)\n    }\n\n    /**\n     * Increase the transfer rate from a given container by a given amount\n     * @param container container\n     * @param rate increase to transfer rate\n     */\n    increaseTransferRate(container: Container, rate: PerSecond) {\n        this.transferRates.set(container, this.transferRates.get(container)! + rate)\n    }\n\n    /**\n     * Calculate the rate at which an item is transferred from a given container\n     * @param container Container to check\n     * @param item Item to check\n     */\n    inflowRateFrom(container: Container, item: Item): PerSecond {\n        if (!this.inputs.has(container)) {\n            return 0\n        }\n        if (this.item !== item) {\n            return 0\n        }\n        if (!this.transferRates.has(container)) {\n            return 0\n        }\n\n        return this.transferRates.get(container)!\n    }\n\n    /**\n     * Calculate the rate at which an item is transferred from a given container\n     * in the steady state limit (after the factory has been running for some time)\n     * @param container Container to check\n     * @param item Item to check\n     */\n    steadyStateInflowRateFrom(container: Container, item: Item): PerSecond {\n        if (!this.inputs.has(container)) {\n            return 0\n        }\n        if (this.item !== item) {\n            return 0\n        }\n        if (!this.transferRates.has(container)) {\n            return 0\n        }\n\n        // estimate that the inflow rate from this container is proportional\n        // to the maximum inflow rate from this container.\n        let totalInflow = Array.from(this.transferRates.values()).reduce(\n            (total, current) => total + current,\n            0,\n        )\n        let fraction = this.inflowRateFrom(container, item) / totalInflow\n        return this.output.steadyStateEgress(item) * fraction\n    }\n\n    /**\n     * Calculate the rate at which an item is added to a given container\n     * @param container Container to check\n     * @param item Item to check\n     */\n    outflowRateTo(container: Container | TransferContainer, item: Item): PerSecond {\n        if (this.output !== container) {\n            return 0\n        }\n        if (this.item !== item) {\n            return 0\n        }\n\n        return Array.from(this.transferRates.values()).reduce(\n            (total, current) => total + current,\n            0,\n        )\n    }\n\n    /**\n     * The number of transfer units required to satisfy transfer rate\n     */\n    get number(): number {\n        const transferRatePer = this.item.transferBatchSize / this.item.transferTime\n        return Math.ceil(this.requiredTransferRate / transferRatePer)\n    }\n}\n\n/**\n * Check if a given element is a TransferUnit\n * @param node element to check\n */\nexport function isTransferUnit(node: Industry | TransferUnit): node is TransferUnit {\n    return node instanceof TransferUnit\n}\n\n/**\n * Check if a transfer unit transfers byproduct\n * @param node transfer unit to check\n */\nexport function isByproductTransferUnit(node: TransferUnit): boolean {\n    // Check if any input containers store this transfer unit's item as byproduct\n    return Array.from(node.inputs).some((input) => {\n        if (input.recipe === undefined) {\n            return false\n        }\n        return Array.from(input.recipe.byproducts.keys()).some(\n            (byproduct) => byproduct === node.item,\n        )\n    })\n}\n\n/**\n * Check if a transfer unit is a catalyst balancer\n * @param node transfer unit to check\n */\nexport function isCatalystBalancer(node: TransferUnit): boolean {\n    // Check if this transfer unit is (B) or (D) such that (A) -> (B) -> (C) -> (D) -> (A)\n    const consumers = Array.from(node.output.consumers)\n    for (const consumer of consumers) {\n        if (isContainer(consumer.output)) {\n            if (Array.from(node.inputs).includes(consumer.output)) {\n                return true\n            }\n        }\n    }\n    return false\n}\n","import { Container } from \"./container\"\nimport { MAX_CONTAINER_LINKS, PerSecond } from \"./graph\"\nimport { Industry } from \"./industry\"\nimport { CONTAINERS_ASCENDING_BY_CAPACITY, Item, Quantity } from \"./items\"\nimport { isByproductTransferUnit, isTransferUnit, TransferUnit } from \"./transfer-unit\"\n\n/**\n * TransferContainers store multiple items to feed industries that\n * require more than MAX_INDUSTRY_LINKS ingredients\n */\nexport class TransferContainer {\n    readonly producers = new Set<TransferUnit>()\n    readonly consumers = new Set<Industry>()\n    // if this element has changed\n    changed = true\n\n    /**\n     * Create a new TransferContainer\n     * @param id Identifier\n     * @param items Items to store\n     */\n    constructor(readonly id: string, readonly items: Item[]) {}\n\n    /**\n     * Get this element's name\n     */\n    get name(): string {\n        return `Trans Container ${this.id}`\n    }\n\n    /**\n     * Count the number of producers\n     */\n    get incomingLinkCount(): number {\n        return this.producers.size\n    }\n\n    /**\n     * Count the number of consumers\n     */\n    get outgoingLinkCount(): number {\n        return this.consumers.size\n    }\n\n    /**\n     * Check if this container can support an additional incoming link\n     */\n    get canAddIncomingLink(): boolean {\n        return this.incomingLinkCount < MAX_CONTAINER_LINKS\n    }\n\n    /**\n     * Check if this container can support an additional incoming link\n     */\n    get canAddOutgoingLink(): boolean {\n        return this.outgoingLinkCount < MAX_CONTAINER_LINKS\n    }\n\n    /**\n     * Add a producer to this container\n     * @param node Producer to add\n     */\n    addProducer(node: TransferUnit) {\n        this.producers.add(node)\n        this.changed = true\n        node.changed = true\n    }\n\n    /**\n     * Remove a consumer from this container\n     * @param node Consumer to remove\n     */\n    removeConsumer(node: Industry) {\n        this.consumers.delete(node)\n        this.changed = true\n        node.changed = true\n    }\n\n    /**\n     * Add a consumer from this container\n     * @param node Consumer to add\n     */\n    addConsumer(node: Industry) {\n        this.consumers.add(node)\n        this.changed = true\n        node.changed = true\n    }\n\n    /**\n     * Calculate the rate at which this container is filled with a given item\n     * @param item Item to check\n     */\n    ingress(item: Item): PerSecond {\n        return Array.from(this.producers)\n            .map((node) => node.outflowRateTo(this, item))\n            .reduce((totalIngress, ingressFrom) => totalIngress + ingressFrom, 0)\n    }\n\n    /**\n     * Calculate the rate at which this container is emptied of a given item\n     * @param item Item to check\n     */\n    egress(item: Item): PerSecond {\n        return Array.from(this.consumers)\n            .map((node) => node.inflowRateFrom(this, item))\n            .reduce((totalEgress, egressTo) => totalEgress + egressTo, 0)\n    }\n\n    /**\n     * Calculate the rate at which this container is emptied of a given item\n     * in the steady state limit (after the factory has been running for some time)\n     * @param item The item\n     */\n    steadyStateEgress(item: Item): PerSecond {\n        return Array.from(this.consumers)\n            .map((node) => node.steadyStateInflowRateFrom(this, item))\n            .reduce((totalEgress, egressTo) => totalEgress + egressTo, 0)\n    }\n\n    /**\n     * Return the required maintain value of a given item to satisfy all consumers\n     * @param item Item for which to calculate maintain value\n     */\n    maintain(item: Item): Quantity {\n        if (!this.items.includes(item)) {\n            return 0\n        }\n\n        let maintain = 0\n        for (const consumer of this.consumers) {\n            // Skip byproduct transfer units\n            if (isTransferUnit(consumer) && isByproductTransferUnit(consumer)) {\n                continue\n            }\n\n            if (isTransferUnit(consumer)) {\n                // For transfer units, get the maintain value of the transfer unit output\n                // divided by the number of transfer unit inputs\n                if (isTransferContainer(consumer.output)) {\n                    maintain += Math.ceil(\n                        consumer.output.maintain(item) / consumer.incomingLinkCount,\n                    )\n                } else {\n                    maintain += Math.ceil(consumer.output.maintain / consumer.incomingLinkCount)\n                }\n            } else {\n                // For industries, get the required input\n                for (const [ingredient, quantity] of consumer.recipe.ingredients.entries()) {\n                    if (ingredient === item) {\n                        maintain += quantity\n                    }\n                }\n            }\n        }\n        return maintain\n    }\n\n    /**\n     * Return the required containers (size)s to hold the maintain values\n     */\n    get containers(): string[] {\n        let remainingCapacity = 0\n        for (const item of this.items) {\n            remainingCapacity += this.maintain(item) * item.volume\n        }\n        const requiredContainers: string[] = []\n        while (remainingCapacity > 0) {\n            let foundContainer = false\n            for (const container of CONTAINERS_ASCENDING_BY_CAPACITY) {\n                if (remainingCapacity <= container.capacity) {\n                    requiredContainers.push(container.name)\n                    remainingCapacity += -container.capacity\n                    foundContainer = true\n                    break\n                }\n            }\n            if (!foundContainer) {\n                // Add one large container\n                requiredContainers.push(\n                    CONTAINERS_ASCENDING_BY_CAPACITY[CONTAINERS_ASCENDING_BY_CAPACITY.length - 1]\n                        .name,\n                )\n                remainingCapacity += -CONTAINERS_ASCENDING_BY_CAPACITY[\n                    CONTAINERS_ASCENDING_BY_CAPACITY.length - 1\n                ].capacity\n            }\n        }\n        return requiredContainers\n    }\n}\n\n/**\n * Check if a given element is a TransferContainer\n * @param node element to check\n */\nexport function isTransferContainer(\n    node: Container | TransferContainer,\n): node is TransferContainer {\n    return node instanceof TransferContainer\n}\n","import { Container, isContainer } from \"./container\"\nimport { PerSecond } from \"./graph\"\nimport { Item, Recipe } from \"./items\"\nimport { isTransferContainer, TransferContainer } from \"./transfer-container\"\nimport { TransferUnit } from \"./transfer-unit\"\nimport { shortenName } from \"./utils\"\n\n/**\n * Industries consume ingredients from containers and produce an item and\n * byproducts to an output container.\n */\nexport class Industry {\n    inputs: Set<Container | TransferContainer> = new Set()\n    output: Container\n    // if this element has changed\n    changed = true\n\n    /**\n     * Create a new Industry producing a given item to a given contianer\n     * @param id Identifier\n     * @param item Item to producer\n     * @param recipe Recipe\n     * @param output Output container\n     */\n    constructor(\n        readonly id: string,\n        readonly item: Item,\n        readonly recipe: Recipe,\n        output: Container,\n    ) {\n        this.output = output\n        output.addProducer(this)\n    }\n\n    /**\n     * Get this element's name\n     */\n    get name(): string {\n        return `${shortenName(this.item.name)} ${this.id}`\n    }\n\n    /**\n     * Remove an input container\n     * @param node Input container to remove\n     */\n    removeInput(node: Container | TransferContainer) {\n        this.inputs.delete(node)\n        node.removeConsumer(this)\n        this.changed = true\n        node.changed = true\n    }\n\n    /**\n     * Add an input container\n     * @param node Input container\n     */\n    addInput(node: Container | TransferContainer) {\n        this.inputs.add(node)\n        node.addConsumer(this)\n        this.changed = true\n        node.changed = true\n    }\n\n    /**\n     * Set the output container\n     * @param node Output container\n     */\n    setOutput(node: Container) {\n        this.output = node\n        node.addProducer(this)\n        this.changed = true\n        node.changed = true\n    }\n\n    /**\n     * Count the number of input containers\n     */\n    get incomingLinkCount(): number {\n        return this.inputs.size\n    }\n\n    /**\n     * Check if an industry has an input supplying a given item\n     * @param item Item to check\n     */\n    isSuppliedWith(item: Item): boolean {\n        for (const input of this.inputs) {\n            if (isTransferContainer(input) && input.items.includes(item)) {\n                return true\n            }\n            if (isContainer(input) && input.item === item) {\n                return true\n            }\n        }\n        return false\n    }\n\n    /**\n     * Calculate the rate at which an ingredient is consumed\n     * @param item Item to check\n     */\n    inflowRateOf(item: Item): PerSecond {\n        for (const [ingredient, quantity] of this.recipe.ingredients.entries()) {\n            if (ingredient === item) {\n                return quantity / this.recipe.time\n            }\n        }\n        return 0\n    }\n\n    /**\n     * Calculate the rate at which an ingredient is consumed\n     * in the steady state limit (after the factory has been running for some time)\n     * @param item Item to check\n     */\n    steadyStateInflowRateOf(item: Item): PerSecond {\n        // get actual egress of produced item from output container\n        let outputEgress = this.output.steadyStateEgress(this.item)\n        // estimate that each producer contributes equally\n        let numProducers = this.output.producers.size\n        for (const [ingredient, quantity] of this.recipe.ingredients.entries()) {\n            if (ingredient === item) {\n                return ((quantity / this.recipe.quantity) * outputEgress) / numProducers\n            }\n        }\n        return 0\n    }\n\n    /**\n     * Calculate the rate at which an ingredient is consumed from a given container\n     * @param container Container to check\n     * @param item Item to check\n     */\n    inflowRateFrom(container: Container | TransferContainer, item: Item): PerSecond {\n        if (!this.inputs.has(container)) {\n            return 0\n        }\n        if (isContainer(container) && container.item !== item) {\n            return 0\n        }\n        if (isTransferContainer(container) && !container.items.includes(item)) {\n            return 0\n        }\n\n        return this.inflowRateOf(item)\n    }\n\n    /**\n     * Calculate the rate at which an ingredient is consumed from a given container\n     * in the steady state limit (after the factory has been running for some time)\n     * @param container Container to check\n     * @param item The item\n     */\n    steadyStateInflowRateFrom(container: Container | TransferContainer, item: Item): PerSecond {\n        if (!this.inputs.has(container)) {\n            return 0\n        }\n        if (isContainer(container) && container.item !== item) {\n            return 0\n        }\n        if (isTransferContainer(container) && !container.items.includes(item)) {\n            return 0\n        }\n\n        return this.steadyStateInflowRateOf(item)\n    }\n\n    /**\n     * Calculate the rate at which a given container is filled with a given item\n     * @param container Container to check\n     * @param item Item to check\n     */\n    outflowRateTo(container: Container, item: Item): PerSecond {\n        if (this.output !== container) {\n            return 0\n        }\n\n        if (this.item === item) {\n            return this.recipe.quantity / this.recipe.time\n        }\n\n        for (const [byproduct, quantity] of this.recipe.byproducts.entries()) {\n            if (byproduct === item) {\n                return quantity / this.recipe.time\n            }\n        }\n\n        return 0\n    }\n}\n\n/**\n * Check if a given element is an Industry\n * @param node element to check\n */\nexport function isIndustry(node: Industry | TransferUnit): node is Industry {\n    return node instanceof Industry\n}\n","import { MAX_CONTAINER_LINKS, PerSecond } from \"./graph\"\nimport { Industry, isIndustry } from \"./industry\"\nimport { CONTAINERS_ASCENDING_BY_CAPACITY, isCatalyst, Item, Quantity, Recipe } from \"./items\"\nimport { TransferContainer } from \"./transfer-container\"\nimport {\n    isByproductTransferUnit,\n    isCatalystBalancer,\n    isTransferUnit,\n    TransferUnit,\n} from \"./transfer-unit\"\nimport { shortenName } from \"./utils\"\n\n/**\n * A container stores a single item. A group of producers feed the\n * container, and a group of consumers draw from the container.\n */\nexport class Container {\n    producers: Set<Industry | TransferUnit> = new Set()\n    consumers: Set<Industry | TransferUnit> = new Set()\n    // The recipe for the item stored in this container\n    recipe: Recipe | undefined\n    // The requested factory output rate\n    outputRate: PerSecond = 0.0\n    // Requested output storage\n    maintainedOutput: Quantity = 0\n    // if this element has changed\n    changed = true\n    // flag if this container is merged with another\n    merged = false\n\n    /**\n     * Create a new Container\n     * @param id Identifier\n     * @param item The item to store\n     * @param recipe Item recipe\n     */\n    constructor(readonly id: string, readonly item: Item, recipe: Recipe | undefined) {\n        this.recipe = recipe\n    }\n\n    /**\n     * Get this element's name\n     */\n    get name(): string {\n        return `${shortenName(this.item.name)} ${this.id}`\n    }\n\n    /**\n     * Count the number of producers\n     */\n    get incomingLinkCount(): number {\n        return Array.from(this.producers)\n            .map((producer) => (isTransferUnit(producer) ? producer.number : 1))\n            .reduce((total, current) => total + current, 0)\n    }\n\n    /**\n     * Count the number of consumers\n     */\n    get outgoingLinkCount(): number {\n        return Array.from(this.consumers)\n            .map((consumer) => (isTransferUnit(consumer) ? consumer.number : 1))\n            .reduce((total, current) => total + current, 0)\n    }\n\n    /**\n     * Number of incoming link slots available\n     */\n    get incomingLinksFree(): number {\n        // need to reserve two incoming links for catalyst balancer if this is a catalyst container\n        let numReserved = isCatalyst(this.item) ? 2 : 0\n        return MAX_CONTAINER_LINKS - this.incomingLinkCount - numReserved\n    }\n\n    /**\n     * Number of outgoing link slots available\n     */\n    get outgoingLinksFree(): number {\n        // need to reserve one link per byproduct if this is a dump container\n        let numReserved =\n            isDumpContainer(this) && this.recipe !== undefined ? this.recipe.byproducts.size : 0\n        // need to reserve two outgoing links for catalyst balancer if this is a catalyst container\n        numReserved += isCatalyst(this.item) ? 2 : 0\n        // need to reserve one link per catalyst if this is a dump container\n        return MAX_CONTAINER_LINKS - this.outgoingLinkCount - numReserved\n    }\n\n    /**\n     * Check that a given number of additional incoming links can be added\n     * @param num Number of new links\n     */\n    canAddIncomingLinks(num: number): boolean {\n        return this.incomingLinksFree >= num\n    }\n\n    /**\n     * Check that a given number of additional outgoing links can be added\n     * @param num Number of new links\n     */\n    canAddOutgoingLinks(num: number): boolean {\n        return this.outgoingLinksFree >= num\n    }\n\n    /**\n     * Set the output rate for this container\n     * @param outputRate the new output rate\n     */\n    setOutputRate(outputRate: number) {\n        this.outputRate = outputRate\n        this.changed = true\n    }\n\n    /**\n     * Set the maintained output for this container\n     * @param maintainedOutput the new maintained output\n     */\n    setMaintainedOutput(maintainedOutput: number) {\n        this.maintainedOutput = maintainedOutput\n        this.changed = true\n    }\n\n    /**\n     * Remove a producer to this container\n     * @param node Producer to remove\n     */\n    removeProducer(node: Industry | TransferUnit) {\n        this.producers.delete(node)\n        this.changed = true\n        node.changed = true\n    }\n\n    /**\n     * Add a producer to this container\n     * @param node Producer to add\n     */\n    addProducer(node: Industry | TransferUnit) {\n        this.producers.add(node)\n        this.changed = true\n        node.changed = true\n    }\n\n    /**\n     * Remove a consumer from this container\n     * @param node Consumer to remove\n     */\n    removeConsumer(node: Industry | TransferUnit) {\n        this.consumers.delete(node)\n        this.changed = true\n        node.changed = true\n    }\n\n    /**\n     * Add a consumer from this container\n     * @param node Consumer to add\n     */\n    addConsumer(node: Industry | TransferUnit) {\n        this.consumers.add(node)\n        this.changed = true\n        node.changed = true\n    }\n\n    /**\n     * Calculate the rate at which this container is filled with a given item\n     * @param item The item\n     */\n    ingress(item: Item): PerSecond {\n        return Array.from(this.producers)\n            .map((node) => node.outflowRateTo(this, item))\n            .reduce((totalIngress, ingressFrom) => totalIngress + ingressFrom, 0)\n    }\n\n    /**\n     * Calculate the rate at which this container is emptied of a given item\n     * @param item The item\n     */\n    egress(item: Item): PerSecond {\n        let egress = 0\n        if (this.item === item) {\n            egress += this.outputRate\n        }\n        // ignore catalyst balancer egress\n        egress += Array.from(this.consumers)\n            .filter((node) => !isTransferUnit(node) || !isCatalystBalancer(node))\n            .map((node) => node.inflowRateFrom(this, item))\n            .reduce((totalEgress, egressTo) => totalEgress + egressTo, 0)\n        return egress\n    }\n\n    /**\n     * Calculate the rate at which this container is emptied of a given item\n     * in the steady state limit (after the factory has been running for some time)\n     * @param item The item\n     */\n    steadyStateEgress(item: Item): PerSecond {\n        let egress = 0\n        if (this.item === item) {\n            egress += this.outputRate\n        }\n        // ignore catalyst balancer egress\n        egress += Array.from(this.consumers)\n            .filter((node) => !isTransferUnit(node) || !isCatalystBalancer(node))\n            .map((node) => node.steadyStateInflowRateFrom(this, item))\n            .reduce((totalEgress, egressTo) => totalEgress + egressTo, 0)\n        return egress\n    }\n\n    /**\n     * Return the required maintain value to store the required components for all consumers\n     */\n    get maintain(): Quantity {\n        let maintain = this.maintainedOutput\n        for (const consumer of this.consumers) {\n            // Skip byproduct transfer units and catalyst balancers\n            if (\n                isTransferUnit(consumer) &&\n                (isByproductTransferUnit(consumer) || isCatalystBalancer(consumer))\n            ) {\n                continue\n            }\n\n            if (isTransferUnit(consumer)) {\n                // For transfer units, get the transfer batch size\n                maintain += consumer.item.transferBatchSize\n            } else {\n                // For industries, get the required input\n                for (const [ingredient, quantity] of consumer.recipe.ingredients.entries()) {\n                    if (ingredient === this.item) {\n                        maintain += quantity\n                    }\n                }\n            }\n        }\n        return maintain\n    }\n\n    /**\n     * Return the required containers (sizes) to hold the maintain value\n     */\n    get containers(): string[] {\n        const requiredContainers: string[] = []\n        let remainingCapacity = this.maintain * this.item.volume\n        while (remainingCapacity > 0) {\n            let foundContainer = false\n            for (const container of CONTAINERS_ASCENDING_BY_CAPACITY) {\n                if (remainingCapacity <= container.capacity) {\n                    requiredContainers.push(container.name)\n                    remainingCapacity += -container.capacity\n                    foundContainer = true\n                    break\n                }\n            }\n            if (!foundContainer) {\n                // Add one large container\n                requiredContainers.push(\n                    CONTAINERS_ASCENDING_BY_CAPACITY[CONTAINERS_ASCENDING_BY_CAPACITY.length - 1]\n                        .name,\n                )\n                remainingCapacity += -CONTAINERS_ASCENDING_BY_CAPACITY[\n                    CONTAINERS_ASCENDING_BY_CAPACITY.length - 1\n                ].capacity\n            }\n        }\n        return requiredContainers\n    }\n}\n\n/**\n * Check if a given element is a Container\n * @param node element to check\n */\nexport function isContainer(node: Container | TransferContainer): node is Container {\n    return node instanceof Container\n}\n\n/**\n * Check if a container is a dump container\n * @param node container to check\n */\nexport function isDumpContainer(node: Container): boolean {\n    // Dump containers have industry producers\n    return Array.from(node.producers).some(isIndustry)\n}\n","import { FactoryNode, ProductionNode, DumpRoute, RelayRoute } from \"./graph\"\nimport { isCatalyst, isGas, isOre, getRecipe } from \"./items\"\nimport { MAX_CONTAINER_LINKS } from \"./graph\"\n\n/**\n * Route a node's relay containers\n * @param node Node to route\n */\nexport function generateRelayRoutes(node: FactoryNode) {\n    // delta to avoid rounding errors\n    const delta = 1.0e-8\n\n    // maximum number of supported transfer units, considering byproducts\n    let maxTransferNumber = MAX_CONTAINER_LINKS\n    if (!isOre(node.item)) {\n        maxTransferNumber =\n            MAX_CONTAINER_LINKS - getRecipe(node.item, node.factory.talentLevels).byproducts.size\n    }\n\n    // maximum rate supported by transfer units\n    const maxTransferRate =\n        (maxTransferNumber * node.item.transferBatchSize) / node.item.transferTime\n\n    // Satisfy all consumers\n    for (const consumer of node.consumers) {\n        // Get consuming industries that need node item\n        let industries = consumer.getIndustriesNeeding(node.item)\n\n        // Add to existing route if links are available\n        for (const relayRoute of node.relayRoutes) {\n            // skip output nodes\n            if (relayRoute.container.outputRate > 0) {\n                continue\n            }\n\n            const addIndustries = Math.min(\n                industries.length,\n                relayRoute.container.outgoingLinksFree,\n            )\n            for (let i = 0; i < addIndustries; i++) {\n                industries[i].addInput(relayRoute.container)\n                relayRoute.transferUnit.increaseRequiredTransferRate(\n                    industries[i].inflowRateOf(node.item),\n                )\n                // check that the number of transfer units can be supported\n                // by the relay container incoming link limit as well as the\n                // dump container outgoing link limit, considering byproducts\n                if (\n                    relayRoute.container.incomingLinksFree < 0 ||\n                    relayRoute.transferUnit.number > maxTransferNumber\n                ) {\n                    industries[i].removeInput(relayRoute.container)\n                    relayRoute.transferUnit.decreaseRequiredTransferRate(\n                        industries[i].inflowRateOf(node.item),\n                    )\n                }\n            }\n            industries = consumer.getIndustriesNeeding(node.item)\n        }\n\n        // Add new relays if necessary\n        let lastLength = industries.length\n        while (industries.length > 0) {\n            // Create container and transfer unit\n            const container = node.factory.createRelayContainer(node.item)\n            const transferUnit = node.factory.createTransferUnit(node.item, container)\n\n            // Add industries\n            const addIndustries = Math.min(industries.length, container.outgoingLinksFree)\n            for (let i = 0; i < addIndustries; i++) {\n                industries[i].addInput(container)\n                transferUnit.increaseRequiredTransferRate(industries[i].inflowRateOf(node.item))\n                // check that the number of transfer units can be supported\n                // by the relay container incoming link limit as well as the\n                // dump container outgoing link limit, considering byproducts\n                if (container.incomingLinksFree < 0 || transferUnit.number > maxTransferNumber) {\n                    industries[i].removeInput(container)\n                    transferUnit.decreaseRequiredTransferRate(industries[i].inflowRateOf(node.item))\n                }\n            }\n            industries = consumer.getIndustriesNeeding(node.item)\n            if (industries.length == lastLength) {\n                throw new Error(\"Recursion error in relay route assignment\")\n            }\n            lastLength = industries.length\n\n            // Add relay route\n            const relayRoute: RelayRoute = {\n                container,\n                transferUnit,\n            }\n            node.relayRoutes.push(relayRoute)\n        }\n    }\n\n    // Route the output relay\n    if (node.outputRate > 0) {\n        let rateDiff = node.outputRate - node.outputRelaysRate\n        let maintainDiff = node.maintainedOutput - node.outputRelaysMaintain\n\n        // increase output rate of existing relays if any\n        for (const route of node.outputRelays) {\n            const increaseRate = Math.min(rateDiff, maxTransferRate - route.container.outputRate)\n            let increaseMaintain = maintainDiff\n            if (rateDiff > 0) {\n                increaseMaintain = (maintainDiff * increaseRate) / rateDiff\n            }\n            route.container.setOutputRate(route.container.outputRate + increaseRate)\n            route.container.setMaintainedOutput(route.container.maintainedOutput + increaseMaintain)\n            route.transferUnit.increaseRequiredTransferRate(increaseRate)\n            rateDiff = rateDiff - increaseRate\n            maintainDiff = maintainDiff - increaseMaintain\n        }\n\n        // Add new output relays as necessary\n        let lastRateDiff = rateDiff\n        while (rateDiff > delta) {\n            const container = node.factory.createRelayContainer(node.item)\n            const transferUnit = node.factory.createTransferUnit(node.item, container)\n            const increaseRate = Math.min(rateDiff, maxTransferRate)\n            let increaseMaintain = maintainDiff\n            increaseMaintain = (maintainDiff * increaseRate) / rateDiff\n            container.setOutputRate(increaseRate)\n            container.setMaintainedOutput(increaseMaintain)\n            transferUnit.increaseRequiredTransferRate(increaseRate)\n            const relayRoute: RelayRoute = {\n                container,\n                transferUnit,\n            }\n            node.relayRoutes.push(relayRoute)\n            rateDiff = rateDiff - increaseRate\n            maintainDiff = maintainDiff - increaseMaintain\n            if (Math.abs(rateDiff - lastRateDiff) < delta) {\n                throw new Error(\"Recursion error in output relay assignment\")\n            }\n            lastRateDiff = rateDiff\n        }\n    }\n}\n\n/**\n * Route a node's dump containers\n * @param node Node to route\n * @param singleGas if True, only create one industry for new gas nodes\n */\nexport function generateDumpRoutes(node: ProductionNode, singleGas: boolean) {\n    // delta to avoid rounding errors\n    const delta = 1.0e-8\n\n    // Try to satisfy all relays using existing dump -> relay links\n    for (const relayRoute of node.getRelayRoutes()) {\n        // Unsatisfied container egress\n        let relayEgress =\n            relayRoute.container.egress(node.item) - relayRoute.container.ingress(node.item)\n        if (relayEgress <= delta) {\n            continue\n        }\n\n        // If this is a catalyst or gas node, try to satisfy from an existing dump container\n        if (isCatalyst(node.item) || (isGas(node.item) && singleGas)) {\n            let found = false\n            for (const dumpRoute of node.dumpRoutes) {\n                if (dumpRoute.container.canAddOutgoingLinks(relayRoute.transferUnit.number)) {\n                    relayRoute.transferUnit.addInput(dumpRoute.container)\n                    relayRoute.transferUnit.increaseTransferRate(dumpRoute.container, relayEgress)\n                    dumpRoute.relayRoutes.push(relayRoute)\n                    found = true\n                }\n            }\n            if (!found) {\n                // Create a new dump route with one industry\n                const dumpContainer = node.factory.createDumpContainer(node.item)\n                const industry = node.factory.createIndustry(node.item, dumpContainer)\n                const dumpRoute: DumpRoute = {\n                    relayRoutes: [relayRoute],\n                    container: dumpContainer,\n                    industries: [industry],\n                }\n                node.dumpRoutes.push(dumpRoute)\n                relayRoute.transferUnit.addInput(dumpContainer)\n                relayRoute.transferUnit.increaseTransferRate(dumpContainer, relayEgress)\n            }\n            continue\n        }\n\n        // Increase production to dump container that already feeds node relay, if possible\n        for (const dumpRoute of node.dumpRoutes) {\n            if (dumpRoute.relayRoutes.includes(relayRoute)) {\n                // How much overproduction we currently have\n                let currentSurplus =\n                    dumpRoute.container.ingress(node.item) - dumpRoute.container.egress(node.item)\n\n                // How much more ingress can we produce\n                const newIngress = dumpRoute.container.incomingLinksFree * node.rate\n\n                // New egress we require\n                let newEgress = Math.min(newIngress + currentSurplus, relayEgress)\n\n                // New industries we require\n                const newIndustries = Math.min(\n                    Math.ceil((newEgress - currentSurplus) / node.rate),\n                    dumpRoute.container.incomingLinksFree,\n                )\n                newEgress = Math.min(currentSurplus + newIndustries * node.rate, relayEgress)\n                for (let i = 0; i < newIndustries; i++) {\n                    const industry = node.factory.createIndustry(node.item, dumpRoute.container)\n                    dumpRoute.industries.push(industry)\n                }\n\n                relayRoute.transferUnit.increaseTransferRate(dumpRoute.container, newEgress)\n            }\n            relayEgress =\n                relayRoute.container.egress(node.item) - relayRoute.container.ingress(node.item)\n        }\n        if (relayEgress <= delta) {\n            continue\n        }\n    }\n\n    // Try to satisfy all relays using existing dump containers\n    for (const relayRoute of node.getRelayRoutes()) {\n        // Unsatisfied container egress\n        let relayEgress =\n            relayRoute.container.egress(node.item) - relayRoute.container.ingress(node.item)\n        if (relayEgress <= delta) {\n            continue\n        }\n\n        // Add to existing route if possible\n        for (const dumpRoute of node.dumpRoutes) {\n            // skip if this dump route cannot support relay\n            if (!dumpRoute.container.canAddOutgoingLinks(relayRoute.transferUnit.number)) {\n                continue\n            }\n\n            // if node dump route is feeding a relay that is supplied by more than\n            // one dump route, then we cannot add any new routes to node dump container\n            const splitDump = dumpRoute.relayRoutes.some((checkRelayRoute) =>\n                node.dumpRoutes.some(\n                    (checkDumpRoute) =>\n                        checkDumpRoute !== dumpRoute &&\n                        checkDumpRoute.relayRoutes.includes(checkRelayRoute),\n                ),\n            )\n            if (splitDump) {\n                continue\n            }\n\n            // if node relay container is already fed by a dump container and node dump\n            // container isn't one of the dump containers feeding node relay, then we\n            // can't add a different existing dump container to node relay\n            const splitRelay = node.dumpRoutes.some(\n                (checkDumpRoute) =>\n                    checkDumpRoute !== dumpRoute && checkDumpRoute.relayRoutes.includes(relayRoute),\n            )\n            if (splitRelay) {\n                continue\n            }\n\n            // How much overproduction we currently have\n            let currentSurplus =\n                dumpRoute.container.ingress(node.item) - dumpRoute.container.egress(node.item)\n\n            // How much more ingress can we produce\n            const newIngress = dumpRoute.container.incomingLinksFree * node.rate\n\n            if (newIngress + currentSurplus >= relayEgress) {\n                // New industries we require\n                const newIndustries = Math.min(\n                    Math.ceil((relayEgress - currentSurplus) / node.rate),\n                    dumpRoute.container.incomingLinksFree,\n                )\n                const newEgress = Math.min(currentSurplus + newIndustries * node.rate, relayEgress)\n                for (let i = 0; i < newIndustries; i++) {\n                    const industry = node.factory.createIndustry(node.item, dumpRoute.container)\n                    dumpRoute.industries.push(industry)\n                }\n\n                dumpRoute.relayRoutes.push(relayRoute)\n                relayRoute.transferUnit.addInput(dumpRoute.container)\n                relayRoute.transferUnit.increaseTransferRate(dumpRoute.container, newEgress)\n            }\n            relayEgress =\n                relayRoute.container.egress(node.item) - relayRoute.container.ingress(node.item)\n        }\n\n        // Create new dump route if necessary\n        let lastEgress = relayEgress\n        while (relayEgress > delta) {\n            const dumpContainer = node.factory.createDumpContainer(node.item)\n\n            const dumpRoute: DumpRoute = {\n                relayRoutes: [relayRoute],\n                container: dumpContainer,\n                industries: [],\n            }\n            const newIndustries = Math.min(\n                Math.ceil(relayEgress / node.rate),\n                dumpContainer.incomingLinksFree,\n            )\n            const newEgress = Math.min(relayEgress, newIndustries * node.rate)\n            for (let i = 0; i < newIndustries; i++) {\n                const industry = node.factory.createIndustry(node.item, dumpContainer)\n                dumpRoute.industries.push(industry)\n            }\n            node.dumpRoutes.push(dumpRoute)\n            relayRoute.transferUnit.addInput(dumpContainer)\n            relayRoute.transferUnit.increaseTransferRate(dumpContainer, newEgress)\n            relayEgress =\n                relayRoute.container.egress(node.item) - relayRoute.container.ingress(node.item)\n            if (Math.abs(relayEgress - lastEgress) < delta) {\n                throw new Error(\"Recursion error in output relay assignments\")\n            }\n            lastEgress = relayEgress\n        }\n    }\n}\n","import { Container, isDumpContainer } from \"./container\"\nimport { Industry } from \"./industry\"\nimport { isGas, Item, Quantity, Recipe, getRecipe, isCraftable } from \"./items\"\nimport { generateDumpRoutes, generateRelayRoutes } from \"./router\"\nimport { TransferContainer } from \"./transfer-container\"\nimport { isByproductTransferUnit, TransferUnit } from \"./transfer-unit\"\n\nexport const MAX_CONTAINER_LINKS = 10\nexport const MAX_INDUSTRY_LINKS = 7\n\nexport type PerSecond = number\n\n/**\n * RelayRoute holds the consuming nodes and the number of consuming industries\n */\nexport interface RelayRoute {\n    container: Container\n    transferUnit: TransferUnit\n}\n\n/**\n * DumpRoute holds the consuming relay routes and egress along each route\n */\nexport interface DumpRoute {\n    relayRoutes: RelayRoute[]\n    container: Container\n    industries: Industry[]\n}\n\n/**\n * A node of the factory graph either stores raw materials or handles\n * the production of a single item.\n */\nexport class FactoryNode {\n    // ProductionNodes consuming from this node\n    consumers: Set<ProductionNode> = new Set()\n    // Requested factory output of this item\n    outputRate: PerSecond = 0\n    // Requested maintain value\n    maintainedOutput: Quantity = 0\n    // Relay routing\n    relayRoutes: RelayRoute[] = []\n    isRelayRouted = false\n\n    /**\n     * Create a new FactoryNode which stores or produces a given item\n     * @param factory the factory\n     * @param item Item to store or produce in this FactoryNode\n     */\n    constructor(readonly factory: FactoryGraph, readonly item: Item) {}\n\n    /**\n     * Add a consumer to this FactoryNode\n     * @param node consumer to add\n     */\n    addConsumer(node: ProductionNode) {\n        this.consumers.add(node)\n    }\n\n    /**\n     * Get this node's output relay(s)\n     */\n    get outputRelays(): RelayRoute[] {\n        return this.relayRoutes.filter((route) => route.container.outputRate > 0)\n    }\n\n    /**\n     * Get the total output rate of this node's output relay containers\n     */\n    get outputRelaysRate(): PerSecond {\n        return this.outputRelays\n            .map((relay) => relay.container.outputRate)\n            .reduce((total, current) => total + current, 0)\n    }\n\n    /**\n     * Get the total maintain value of this node's output relay containers\n     */\n    get outputRelaysMaintain(): Quantity {\n        return this.outputRelays\n            .map((relay) => relay.container.maintainedOutput)\n            .reduce((total, current) => total + current, 0)\n    }\n\n    /**\n     * Route the relay containers\n     */\n    getRelayRoutes(): RelayRoute[] {\n        // Check if we've already routed this node\n        if (this.isRelayRouted) {\n            return this.relayRoutes\n        }\n\n        generateRelayRoutes(this)\n\n        this.isRelayRouted = true\n        return this.relayRoutes\n    }\n}\n\n/**\n * A FactoryNode that only stores raw ores.\n */\nclass OreNode extends FactoryNode {\n    /**\n     * Create a new OreNode that stores a given item\n     * @param factory the factory\n     * @param item Ore to store\n     */\n    constructor(readonly factory: FactoryGraph, readonly item: Item) {\n        super(factory, item)\n    }\n}\n\n/**\n * Check if a given node is an OreNode\n * @param node Node to check\n */\nexport function isOreNode(node: FactoryNode): node is OreNode {\n    return node instanceof OreNode\n}\n\n/**\n * A FactoryNode that produces an item\n */\nexport class ProductionNode extends FactoryNode {\n    // Item's recipe\n    recipe: Recipe\n    // Dump container routing\n    dumpRoutes: DumpRoute[] = []\n    isDumpRouted = false\n\n    /**\n     * Create a new ProductionNode that produces a given item\n     * @param factory the factory\n     * @param item Item to produce\n     */\n    constructor(readonly factory: FactoryGraph, readonly item: Item) {\n        super(factory, item)\n        this.recipe = getRecipe(item, factory.talentLevels)\n    }\n\n    /**\n     * Get production rate per industry\n     */\n    get rate(): PerSecond {\n        return this.recipe.quantity / this.recipe.time\n    }\n\n    /**\n     * Route the dump containers\n     */\n    getDumpRoutes(): DumpRoute[] {\n        // Check if we've already routed this node\n        if (this.isDumpRouted) {\n            return this.dumpRoutes\n        }\n\n        generateDumpRoutes(this, true)\n\n        this.isDumpRouted = true\n        return this.dumpRoutes\n    }\n\n    /**\n     * Return all industries not currently supplied by the given item\n     */\n    getIndustriesNeeding(item: Item): Industry[] {\n        const industries: Industry[] = []\n        for (const dumpRoute of this.getDumpRoutes()) {\n            for (const industry of dumpRoute.industries) {\n                if (!industry.isSuppliedWith(item)) {\n                    industries.push(industry)\n                }\n            }\n        }\n        return industries\n    }\n}\n\n/**\n * Check if a given node is a ProductionNode\n * @param node Node to check\n */\nexport function isProductionNode(node: FactoryNode): node is ProductionNode {\n    return node instanceof ProductionNode\n}\n\n/**\n * The factory graph stores all nodes and elements in a factory\n */\nexport class FactoryGraph {\n    nodes: Map<Item, FactoryNode> = new Map()\n    containers: Set<Container> = new Set()\n    industries: Set<Industry> = new Set()\n    transferUnits: Set<TransferUnit> = new Set()\n    transferContainers: Set<TransferContainer> = new Set()\n\n    /**\n     * Create a new FactoryGraph\n     * @param talentLevels Talent levels\n     */\n    constructor(readonly talentLevels: { [key: string]: number }) {}\n\n    /**\n     * Return a node that stores or produces a given item\n     * @param item Item to find\n     */\n    getNode(item: Item): FactoryNode | undefined {\n        return this.nodes.get(item)\n    }\n\n    /**\n     * Return the factory's OreNodes\n     */\n    get oreNodes(): OreNode[] {\n        return Array.from(this.nodes.values()).filter(isOreNode)\n    }\n\n    /**\n     * Return the factory's nodes storing gas\n     */\n    get gasNodes(): ProductionNode[] {\n        return Array.from(this.nodes.values())\n            .filter(isProductionNode)\n            .filter((node) => isGas(node.item))\n    }\n\n    /**\n     * Return all dump containers in the factory\n     */\n    get dumpContainers(): Container[] {\n        return Array.from(this.containers).filter(isDumpContainer)\n    }\n\n    /**\n     * Return all dump containers storing a given item\n     * @param item Item to find\n     */\n    getDumpContainers(item: Item): Container[] {\n        return Array.from(this.containers)\n            .filter(isDumpContainer)\n            .filter((node) => node.item === item)\n    }\n\n    /**\n     * Return all relay containers storing a given item\n     * @param item Item to find\n     */\n    getRelayContainers(item: Item): Container[] {\n        return Array.from(this.containers)\n            .filter((node) => !isDumpContainer(node))\n            .filter((node) => node.item === item)\n    }\n\n    /**\n     * Return all transfer units moving a given item\n     * @param item Item to find\n     */\n    getTransferUnits(item: Item): TransferUnit[] {\n        return Array.from(this.transferUnits).filter((node) => node.item === item)\n    }\n\n    /**\n     * Return all byproduct transfer units moving a given item\n     * @param item Item to find\n     */\n    getByproductTransferUnits(item: Item): TransferUnit[] {\n        return Array.from(this.transferUnits)\n            .filter(isByproductTransferUnit)\n            .filter((node) => node.item === item)\n    }\n\n    /**\n     * Return all industries producing a given item\n     * @param item Item to find\n     */\n    getIndustries(item: Item): Industry[] {\n        return Array.from(this.industries).filter((node) => node.item === item)\n    }\n\n    /**\n     * Return the set of all transfer containers holding one or more of the\n     * given items and no other items\n     * @param items Items for which to find the TransferContainers\n     */\n    getTransferContainers(items: Set<Item>): Set<TransferContainer> {\n        let transferContainers = Array.from(this.transferContainers)\n        // Filter only those containing one or more of items\n        transferContainers = transferContainers.filter((node) =>\n            node.items.some((item) => Array.from(items).includes(item)),\n        )\n        // Filter out those containing anything not in items\n        transferContainers = transferContainers.filter(\n            (node) => !node.items.some((item) => !Array.from(items).includes(item)),\n        )\n        return new Set(transferContainers)\n    }\n\n    /**\n     * Add an OreNode to the factory\n     * @param item Ore stored in this node\n     */\n    createOreNode(item: Item): OreNode {\n        const node = new OreNode(this, item)\n        this.nodes.set(item, node)\n        return node\n    }\n\n    /**\n     * Add a ProductionNode to the factory\n     * @param item Item to produce in this node\n     */\n    createProductionNode(item: Item): ProductionNode {\n        const node = new ProductionNode(this, item)\n        this.nodes.set(item, node)\n        return node\n    }\n\n    /**\n     * Add a relay container to the factory\n     * @param item Item to store\n     * @param id Identifier\n     */\n    createRelayContainer(item: Item, id?: string): Container {\n        if (id === undefined) {\n            const containers = this.getRelayContainers(item)\n            id = `R${containers.length}`\n        }\n        let recipe = undefined\n        if (isCraftable(item)) {\n            recipe = getRecipe(item, this.talentLevels)\n        }\n        const container = new Container(id, item, recipe)\n        this.containers.add(container)\n        return container\n    }\n\n    /**\n     * Add a dump container to the factory\n     * @param item Item to store\n     * @param id Identifier\n\n     */\n    createDumpContainer(item: Item, id?: string): Container {\n        if (id === undefined) {\n            const containers = this.getDumpContainers(item)\n            id = `D${containers.length}`\n        }\n        let recipe = undefined\n        if (isCraftable(item)) {\n            recipe = getRecipe(item, this.talentLevels)\n        }\n        const container = new Container(id, item, recipe)\n        this.containers.add(container)\n        return container\n    }\n\n    /**\n     * Add a transfer container to the factory\n     * @param items Items to store\n     */\n    createTransferContainer(items: Item[], id?: string): TransferContainer {\n        if (id === undefined) {\n            id = `TC${this.transferContainers.size}`\n        }\n        const container = new TransferContainer(id, items)\n        this.transferContainers.add(container)\n        return container\n    }\n\n    /**\n     * Add an Industry to the factory\n     * @param item Item to produce\n     * @param output Output container\n     */\n    createIndustry(item: Item, output: Container, id?: string): Industry {\n        if (id === undefined) {\n            const industries = this.getIndustries(item)\n            id = `P${industries.length}`\n        }\n        const industry = new Industry(id, item, getRecipe(item, this.talentLevels), output)\n        this.industries.add(industry)\n        return industry\n    }\n\n    /**\n     * Add a TransferUnit to the factory\n     * @param item Item to move\n     * @param output Output container\n     */\n    createTransferUnit(\n        item: Item,\n        output: Container | TransferContainer,\n        id?: string,\n    ): TransferUnit {\n        if (id === undefined) {\n            const transferUnits = this.getTransferUnits(item)\n            id = `T${transferUnits.length}`\n        }\n        const transferUnit = new TransferUnit(id, item, output)\n        this.transferUnits.add(transferUnit)\n        return transferUnit\n    }\n}\n","import { Container } from \"./container\"\nimport {\n    FactoryGraph,\n    FactoryNode,\n    MAX_CONTAINER_LINKS,\n    MAX_INDUSTRY_LINKS,\n    PerSecond,\n} from \"./graph\"\nimport { CATALYSTS, isOre, Item, getRecipe } from \"./items\"\nimport { generateDumpRoutes } from \"./router\"\nimport { isTransferContainer, TransferContainer } from \"./transfer-container\"\nimport { isTransferUnit } from \"./transfer-unit\"\nimport { sanityCheck, mergeFactory, unmergeFactory } from \"./utils\"\n\n/**\n * Add a production node for a given item if it doesn't exist, then call this function\n * recursively for all item ingredients.\n * @param item Item to produce\n * @param factory the FactoryGraph\n */\nfunction addProductionNode(item: Item, factory: FactoryGraph): FactoryNode {\n    // Get node if it exists\n    const node = factory.getNode(item)\n    if (node !== undefined) {\n        return node\n    }\n\n    // Create an ore node and terminate recursion\n    if (isOre(item)) {\n        const oreNode = factory.createOreNode(item)\n        return oreNode\n    }\n\n    // Add this item to the tree\n    const productionNode = factory.createProductionNode(item)\n\n    // Add all ingredients\n    const recipe = getRecipe(item, factory.talentLevels)\n    for (const [ingredient, quantity] of recipe.ingredients.entries()) {\n        // Catch empty recipes (e.g., gas)\n        if (ingredient === undefined) {\n            continue\n        }\n\n        // Add ingredients to tree\n        const inputNode = addProductionNode(ingredient, factory)\n\n        // Link ingredients to node\n        inputNode.addConsumer(productionNode)\n    }\n\n    // Return new node\n    return productionNode\n}\n\n/**\n * Add transfer units to move byproducts\n * @param factory the factory graph\n */\nfunction handleByproducts(factory: FactoryGraph) {\n    // Handle byproducts\n    for (const container of factory.dumpContainers) {\n        if (container.recipe === undefined) {\n            // no byproducts\n            continue\n        }\n\n        for (const [byproduct, quantity] of container.recipe.byproducts.entries()) {\n            // maximum transfer rate supported by a single transfer unit\n            const maxTransferRate = byproduct.transferBatchSize / byproduct.transferTime\n\n            // Check if this container already has a transfer unit for the byproduct\n            let found = false\n            for (const consumer of container.consumers) {\n                if (isTransferUnit(consumer) && consumer.item == byproduct) {\n                    found = true\n                    // ensure that the transfer rate is set\n                    consumer.setTransferRate(container, container.ingress(byproduct))\n                    // ensure that we do not exceed one transfer unit for this byproduct\n                    // THIS IS A HACK\n                    if (consumer.requiredTransferRate > maxTransferRate) {\n                        for (const tuContainer of consumer.inputs) {\n                            const share = container.ingress(byproduct) / maxTransferRate\n                            consumer.setTransferRate(\n                                tuContainer,\n                                share * container.ingress(byproduct),\n                            )\n                        }\n                        consumer.requiredTransferRate = maxTransferRate\n                    }\n                    break\n                }\n            }\n            if (found) {\n                continue\n            }\n\n            // Look for an existing transfer unit\n            let foundTransferUnit = false\n            const transferUnits = factory.getByproductTransferUnits(byproduct)\n            for (const transferUnit of transferUnits) {\n                if (transferUnit.canAddIncomingLink) {\n                    foundTransferUnit = true\n                    transferUnit.addInput(container)\n                    transferUnit.increaseTransferRate(container, container.ingress(byproduct))\n                    // ensure that we do not exceed one transfer unit for this byproduct\n                    // THIS IS A HACK\n                    if (transferUnit.requiredTransferRate > maxTransferRate) {\n                        for (const tuContainer of transferUnit.inputs) {\n                            const share = container.ingress(byproduct) / maxTransferRate\n                            transferUnit.setTransferRate(\n                                tuContainer,\n                                share * container.ingress(byproduct),\n                            )\n                        }\n                        transferUnit.requiredTransferRate = maxTransferRate\n                    }\n                    break\n                }\n            }\n            if (foundTransferUnit) {\n                continue\n            }\n\n            // Find a dump container storing byproduct that doesn't already have\n            // a transfer unit dumping into it and can support an additional incoming link\n            const dumpContainers = factory.getDumpContainers(byproduct)\n            let outputContainer = undefined\n            let minTransferUnits = MAX_CONTAINER_LINKS\n            for (const checkContainer of dumpContainers) {\n                const numTransferUnits = Array.from(checkContainer.producers).filter(\n                    isTransferUnit,\n                ).length\n                minTransferUnits = Math.min(minTransferUnits, numTransferUnits)\n                if (checkContainer.canAddIncomingLinks(1) && numTransferUnits === 0) {\n                    outputContainer = checkContainer\n                    break\n                }\n            }\n\n            // Find a dump container storing byproduct that can support an additional incoming link\n            // and has the minimum number of transfer units\n            if (outputContainer === undefined) {\n                for (const checkContainer of dumpContainers) {\n                    const numTransferUnits = Array.from(checkContainer.producers).filter(\n                        isTransferUnit,\n                    ).length\n                    if (\n                        checkContainer.canAddIncomingLinks(1) &&\n                        numTransferUnits === minTransferUnits\n                    ) {\n                        outputContainer = checkContainer\n                        break\n                    }\n                }\n            }\n\n            // Create a new DumpContainer for this product if necessary\n            if (outputContainer === undefined) {\n                outputContainer = factory.createDumpContainer(byproduct)\n            }\n\n            // Add new transfer unit\n            const transferUnit = factory.createTransferUnit(byproduct, outputContainer)\n            transferUnit.increaseRequiredTransferRate(container.ingress(byproduct))\n            transferUnit.addInput(container)\n            transferUnit.increaseTransferRate(container, container.ingress(byproduct))\n            // ensure that we do not exceed one transfer unit for this byproduct\n            // THIS IS A HACK\n            if (transferUnit.requiredTransferRate > maxTransferRate) {\n                transferUnit.setTransferRate(container, maxTransferRate)\n                transferUnit.requiredTransferRate = maxTransferRate\n            }\n        }\n    }\n}\n\n/**\n * Add transfer units to balance catalysts\n * @param factory the factory graph\n */\nfunction balanceCatalysts(factory: FactoryGraph) {\n    // Chain catalyst dump containers together (0 <-> 1 <-> 2 ... etc.)\n    for (const catalyst of CATALYSTS) {\n        const containers = factory.getDumpContainers(catalyst)\n        let lastContainer: Container | undefined = undefined\n        for (const container of containers) {\n            if (lastContainer === undefined) {\n                lastContainer = container\n                continue\n            }\n\n            // check if previous container has a link to this one\n            let transferUnits = Array.from(lastContainer.consumers)\n                .filter(isTransferUnit)\n                .filter((node) => node.output === container)\n            if (transferUnits.length === 0) {\n                const transferUnit = factory.createTransferUnit(catalyst, container)\n                const rate: PerSecond = 1.0 / 11.0 // HACK\n                transferUnit.increaseRequiredTransferRate(rate)\n                transferUnit.addInput(lastContainer)\n                transferUnit.increaseTransferRate(lastContainer, rate)\n            }\n\n            // check if this container has link to previous one\n            transferUnits = Array.from(container.consumers)\n                .filter(isTransferUnit)\n                .filter((node) => node.output === lastContainer)\n            if (transferUnits.length === 0) {\n                const transferUnit = factory.createTransferUnit(catalyst, lastContainer)\n                const rate: PerSecond = 1.0 / 11.0 // HACK\n                transferUnit.increaseRequiredTransferRate(rate)\n                transferUnit.addInput(container)\n                transferUnit.increaseTransferRate(container, rate)\n            }\n            lastContainer = container\n        }\n    }\n}\n\n/**\n * Add TransferContainers as necessary to satisfy industries that required too many links\n * @param factory the factory graph\n */\nfunction handleTransferContainers(factory: FactoryGraph) {\n    // Add transfer containers for industries with too many incoming links\n    for (const industry of factory.industries) {\n        const exceedingLinkCount = industry.incomingLinkCount - MAX_INDUSTRY_LINKS\n        if (exceedingLinkCount <= 0) {\n            continue\n        }\n\n        // Sort ingredients by quantity\n        const ingredients = Array.from(\n            new Map([...industry.recipe.ingredients.entries()].sort((a, b) => a[1] - b[1])).keys(),\n        )\n\n        // Try to use an existing transfer container\n        const transferContainers = factory.getTransferContainers(new Set(ingredients))\n        let transferContainer: TransferContainer | undefined = undefined\n        for (const checkTransferContainer of transferContainers) {\n            // We need to remove (exceedingLinkCount + 1) links from the industry and add\n            // one link from a transfer container. Check if this transfer container holds\n            // at least (exceedingLinkCount + 1) items.\n            if (checkTransferContainer.items.length < exceedingLinkCount + 1) {\n                continue\n            }\n\n            // Check that we can add an outgoing link\n            if (!checkTransferContainer.canAddOutgoingLink) {\n                continue\n            }\n\n            // We have to ensure that the ingredients are drawn from the relay containers\n            // that this industry uses. Check that each transfer container transfer unit\n            // draws from one of the industry inputs.\n            let transferUnitsGood = true\n            for (const transferUnit of checkTransferContainer.producers) {\n                if (!Array.from(transferUnit.inputs).some((input) => industry.inputs.has(input))) {\n                    transferUnitsGood = false\n                }\n            }\n            if (!transferUnitsGood) {\n                continue\n            }\n\n            // good\n            transferContainer = checkTransferContainer\n            break\n        }\n\n        // Create a new transfer container if necessary\n        if (transferContainer === undefined) {\n            const items = ingredients.slice(0, exceedingLinkCount + 1)\n            transferContainer = factory.createTransferContainer(items)\n\n            // Add transfer units\n            for (const item of items) {\n                const transferUnit = factory.createTransferUnit(item, transferContainer)\n            }\n        }\n\n        // Remove existing container->industry links, and replace with\n        // container->transfer unit links\n        for (const transferUnit of transferContainer.producers) {\n            let check = false\n            for (const container of industry.inputs) {\n                if (isTransferContainer(container)) {\n                    continue\n                }\n                if (container.item === transferUnit.item) {\n                    const transferRate = industry.inflowRateFrom(container, container.item)\n                    industry.removeInput(container)\n                    transferUnit.addInput(container)\n                    transferUnit.increaseRequiredTransferRate(transferRate)\n                    transferUnit.increaseTransferRate(container, transferRate)\n                    check = true\n                    break\n                }\n            }\n            if (!check) {\n                console.log(industry)\n                console.log(transferUnit)\n                throw new Error(\"Unable to transfer item\")\n            }\n        }\n\n        // Link transfer container to industry\n        industry.addInput(transferContainer)\n    }\n}\n\n/**\n * Add gas producers to satisfy gas nodes\n * @param factory the factory graph\n */\nfunction handleGas(factory: FactoryGraph) {\n    // Loop over gas nodes\n    for (const node of factory.gasNodes) {\n        // update relay node transfer unit transfer rate\n        // to match fractional production normalized by\n        // relay throughput, or actual consumption rate,\n        // whichever is smaller\n        const totalEgress = node\n            .getRelayRoutes()\n            .map((route) => route.container.egress(node.item))\n            .reduce((total, current) => total + current, 0)\n\n        for (const relayRoute of node.getRelayRoutes()) {\n            for (const dumpRoute of node.dumpRoutes) {\n                const transferRate = Math.min(\n                    relayRoute.container.egress(node.item),\n                    (dumpRoute.container.ingress(node.item) *\n                        relayRoute.container.egress(node.item)) /\n                        totalEgress,\n                )\n\n                relayRoute.transferUnit.setTransferRate(dumpRoute.container, transferRate)\n            }\n        }\n\n        // update dump routes allowing gas nodes to have multiple industries\n        generateDumpRoutes(node, false)\n    }\n}\n\n/**\n * Build a new factory graph or add to an existing graph\n * @param requirements The items and rates of new items to produce\n * @param talentLevels Talent levels\n * @param factory The existing factory graph, if any\n */\nexport function buildFactory(\n    requirements: Map<Item, { rate: PerSecond; maintain: number }>,\n    talentLevels: { [key: string]: number },\n    factory?: FactoryGraph,\n) {\n    // Start a new graph if necessary\n    if (factory === undefined) {\n        factory = new FactoryGraph(talentLevels)\n    } else {\n        // Umerge dump and relay containers\n        unmergeFactory(factory)\n    }\n\n    // Add required production nodes\n    for (const [item, { rate, maintain }] of requirements.entries()) {\n        // add or update production node for this item\n        const node = addProductionNode(item, factory)\n        node.outputRate += rate\n        node.maintainedOutput += maintain\n    }\n\n    // Route and build nodes starting from the raw ores\n    for (const node of factory.oreNodes) {\n        node.getRelayRoutes()\n    }\n    // Route and build nodes starting from the gas dump routes\n    for (const node of factory.gasNodes) {\n        node.getDumpRoutes()\n    }\n\n    // Transfer byproducts\n    handleByproducts(factory)\n\n    // Balance catalysts\n    balanceCatalysts(factory)\n\n    // Handle transfer contianers\n    handleTransferContainers(factory)\n\n    // Add gas producers if necessary\n    handleGas(factory)\n\n    // Merge dump and relay containers\n    mergeFactory(factory)\n\n    // sanity check\n    sanityCheck(factory)\n\n    return factory\n}\n","import { Container, isContainer } from \"./container\"\nimport {\n    FactoryGraph,\n    FactoryNode,\n    isProductionNode,\n    ProductionNode,\n    DumpRoute,\n    RelayRoute,\n} from \"./graph\"\nimport { Industry, isIndustry } from \"./industry\"\nimport { isOre, Item, ITEMS } from \"./items\"\nimport { isTransferContainer, TransferContainer } from \"./transfer-container\"\nimport { isTransferUnit, TransferUnit } from \"./transfer-unit\"\n\n// Factory JSON version number\nconst VERSION = \"4.1\"\n\n/**\n * Saved properties for each FactoryNode\n */\ninterface SaveFactoryNode {\n    item: Item\n    consumers: number[]\n    outputRate: number\n    maintainedOutput: number\n    relayRouteContainers: number[]\n    relayRouteTransferUnits: number[]\n    dumpRouteRelays: number[][]\n    dumpRouteContainers: number[]\n    dumpRouteIndustries: number[][]\n}\n\n/**\n * Saved properties for each Container\n */\ninterface SaveContainer {\n    id: string\n    merged: boolean\n    item: Item\n    outputRate: number\n    maintainedOutput: number\n    maintain: number\n    containers: string[]\n    producerIndustries: number[]\n    producerTransferUnits: number[]\n    consumerIndustries: number[]\n    consumerTransferUnits: number[]\n}\n\n/**\n * Saved properties for each TransferContainer\n */\ninterface SaveTransferContainer {\n    id: string\n    items: Item[]\n    maintain: number[]\n    containers: string[]\n    producers: number[]\n    consumers: number[]\n}\n\n/**\n * Saved properties for each Industry\n */\ninterface SaveIndustry {\n    id: string\n    industry: string\n    item: Item\n    inputContainers: number[]\n    inputTransferContainers: number[]\n    output: number\n}\n\n/**\n * Saved properties for each TransferUnit\n */\ninterface SaveTransferUnit {\n    id: string\n    merged: boolean\n    item: Item\n    inputs: number[]\n    requiredTransferRate: number\n    rates: number[]\n    outputContainer: number | undefined\n    outputTransferContainer: number | undefined\n}\n\n/**\n * Serialize a factory as a JSON string\n * @param factory the FactoryGraph to serialize\n */\nexport function serialize(factory: FactoryGraph): string {\n    const factoryNodes = Array.from(factory.nodes.values())\n    const factoryContainers = Array.from(factory.containers)\n    const factoryIndustries = Array.from(factory.industries)\n    const factoryTransferUnits = Array.from(factory.transferUnits)\n    const factoryTransferContainers = Array.from(factory.transferContainers)\n\n    const saveFactory = {\n        version: VERSION,\n        talentLevels: factory.talentLevels,\n        nodes: [] as SaveFactoryNode[],\n        containers: [] as SaveContainer[],\n        transferContainers: [] as SaveTransferContainer[],\n        industries: [] as SaveIndustry[],\n        transferUnits: [] as SaveTransferUnit[],\n    }\n\n    /**\n     * Save Containers by replacing cyclic references with indicies\n     */\n    for (const container of factoryContainers) {\n        const saveContainer: SaveContainer = {\n            id: container.id,\n            merged: container.merged,\n            item: container.item,\n            outputRate: container.outputRate,\n            maintainedOutput: container.maintainedOutput,\n            maintain: container.maintain,\n            containers: container.containers,\n            producerIndustries: Array.from(container.producers)\n                .filter(isIndustry)\n                .map((node) => factoryIndustries.indexOf(node))\n                .sort(),\n            producerTransferUnits: Array.from(container.producers)\n                .filter(isTransferUnit)\n                .map((node) => factoryTransferUnits.indexOf(node))\n                .sort(),\n            consumerIndustries: Array.from(container.consumers)\n                .filter(isIndustry)\n                .map((node) => factoryIndustries.indexOf(node))\n                .sort(),\n            consumerTransferUnits: Array.from(container.consumers)\n                .filter(isTransferUnit)\n                .map((node) => factoryTransferUnits.indexOf(node))\n                .sort(),\n        }\n        saveFactory.containers.push(saveContainer)\n    }\n\n    /**\n     * Save Industries by replacing cyclic references with indicies\n     */\n    for (const industry of factoryIndustries) {\n        const saveIndustry: SaveIndustry = {\n            id: industry.id,\n            item: industry.item,\n            industry: industry.recipe.industry,\n            inputContainers: Array.from(industry.inputs)\n                .filter(isContainer)\n                .map((node) => factoryContainers.indexOf(node))\n                .sort(),\n            inputTransferContainers: Array.from(industry.inputs)\n                .filter(isTransferContainer)\n                .map((node) => factoryTransferContainers.indexOf(node))\n                .sort(),\n            output: factoryContainers.indexOf(industry.output),\n        }\n        saveFactory.industries.push(saveIndustry)\n    }\n\n    /**\n     * Save TransferUnits by replacing cyclic references with indicies\n     */\n    for (const transferUnit of factoryTransferUnits) {\n        const saveTransferUnit: SaveTransferUnit = {\n            id: transferUnit.id,\n            merged: transferUnit.merged,\n            item: transferUnit.item,\n            inputs: Array.from(transferUnit.inputs).map((node) => factoryContainers.indexOf(node)),\n            requiredTransferRate: transferUnit.requiredTransferRate,\n            rates: Array.from(transferUnit.inputs).map(\n                (input) => transferUnit.transferRates.get(input)!,\n            ),\n            outputContainer: isContainer(transferUnit.output)\n                ? factoryContainers.indexOf(transferUnit.output)\n                : undefined,\n            outputTransferContainer: isTransferContainer(transferUnit.output)\n                ? factoryTransferContainers.indexOf(transferUnit.output)\n                : undefined,\n        }\n        saveFactory.transferUnits.push(saveTransferUnit)\n    }\n\n    /**\n     * Save TransferContainers by replacing cyclic references with indicies\n     */\n    for (const transferContainer of factoryTransferContainers) {\n        const items: Item[] = []\n        const maintain: number[] = []\n        for (const item of transferContainer.items) {\n            items.push(item)\n            maintain.push(transferContainer.maintain(item))\n        }\n        const saveTransferContainer: SaveTransferContainer = {\n            id: transferContainer.id,\n            items: items,\n            maintain: maintain,\n            containers: transferContainer.containers,\n            producers: Array.from(transferContainer.producers)\n                .map((node) => factoryTransferUnits.indexOf(node))\n                .sort(),\n            consumers: Array.from(transferContainer.consumers)\n                .map((node) => factoryIndustries.indexOf(node))\n                .sort(),\n        }\n        saveFactory.transferContainers.push(saveTransferContainer)\n    }\n\n    /**\n     * Save FactoryNodes by replacing cyclic references with indicies\n     */\n    for (const node of factoryNodes) {\n        const saveRelayContainers: number[] = []\n        const saveRelayTransferUnits: number[] = []\n        for (const relayRoute of node.getRelayRoutes()) {\n            saveRelayContainers.push(factoryContainers.indexOf(relayRoute.container))\n            saveRelayTransferUnits.push(factoryTransferUnits.indexOf(relayRoute.transferUnit))\n        }\n\n        const saveDumpRelays: number[][] = []\n        const saveDumpContainers: number[] = []\n        const saveDumpIndustries: number[][] = []\n        if (isProductionNode(node)) {\n            for (const dumpRoute of node.getDumpRoutes()) {\n                saveDumpRelays.push(\n                    dumpRoute.relayRoutes.map((relayRoute) =>\n                        node.getRelayRoutes().indexOf(relayRoute),\n                    ),\n                )\n                saveDumpContainers.push(factoryContainers.indexOf(dumpRoute.container))\n                saveDumpIndustries.push(\n                    dumpRoute.industries.map((industry) => factoryIndustries.indexOf(industry)),\n                )\n            }\n        }\n\n        const saveFactoryNode: SaveFactoryNode = {\n            item: node.item,\n            consumers: Array.from(node.consumers)\n                .map((consumer) => factoryNodes.indexOf(consumer))\n                .sort(),\n            outputRate: node.outputRate,\n            maintainedOutput: node.maintainedOutput,\n            relayRouteContainers: saveRelayContainers,\n            relayRouteTransferUnits: saveRelayTransferUnits,\n            dumpRouteRelays: saveDumpRelays,\n            dumpRouteContainers: saveDumpContainers,\n            dumpRouteIndustries: saveDumpIndustries,\n        }\n        saveFactory.nodes.push(saveFactoryNode)\n    }\n\n    return JSON.stringify(saveFactory, null, 4)\n}\n\n/**\n * De-serialize a JSON string representation of a FactoryGraph\n * @param serializedFactory the serialized FactoryGraph\n */\nexport function deserialize(\n    serializedFactory: string,\n    talentLevels: { [key: string]: number },\n): FactoryGraph {\n    const saveFactory = JSON.parse(serializedFactory)\n    if (saveFactory.version !== VERSION) {\n        throw new Error(\"Invalid JSON version: \" + saveFactory.version + \". Expected: \" + VERSION)\n    }\n    // ensure that the talents used to generate the loaded factory\n    // are no better than the current user's talents\n    for (const [talent, level] of Object.entries(saveFactory.talentLevels)) {\n        if (talentLevels[talent] === undefined || talentLevels[talent] < (level as number)) {\n            throw new Error(\n                \"Your talent levels must match or exceed the talent levels used to generate the original factory.\",\n            )\n        }\n    }\n    const factory = new FactoryGraph(talentLevels)\n\n    const factoryContainers: Container[] = []\n    const factoryTransferContainers: TransferContainer[] = []\n    const factoryIndustries: Industry[] = []\n    const factoryTransferUnits: TransferUnit[] = []\n    const factoryNodes: FactoryNode[] = []\n\n    // Unpack Containers\n    for (const saveContainer of saveFactory.containers) {\n        const item = ITEMS[saveContainer.item.name as keyof typeof ITEMS]\n        const container = factory.createRelayContainer(item, saveContainer.id)\n        container.merged = saveContainer.merged\n        container.outputRate = saveContainer.outputRate\n        container.maintainedOutput = saveContainer.maintainedOutput\n        factoryContainers.push(container)\n    }\n\n    // Unpack TransferContainers\n    for (const saveTransferContainer of saveFactory.transferContainers) {\n        const items = saveTransferContainer.items.map(\n            (item: Item) => ITEMS[item.name as keyof typeof ITEMS],\n        )\n        const transferContainer = factory.createTransferContainer(items, saveTransferContainer.id)\n        factoryTransferContainers.push(transferContainer)\n    }\n\n    // Unpack Industries\n    for (const saveIndustry of saveFactory.industries) {\n        const item = ITEMS[saveIndustry.item.name as keyof typeof ITEMS]\n        const industry = factory.createIndustry(\n            item,\n            factoryContainers[saveIndustry.output],\n            saveIndustry.id,\n        )\n\n        // Add links\n        for (const input of saveIndustry.inputContainers) {\n            industry.addInput(factoryContainers[input])\n        }\n        for (const input of saveIndustry.inputTransferContainers) {\n            industry.addInput(factoryTransferContainers[input])\n        }\n\n        factoryIndustries.push(industry)\n    }\n\n    // Unpack TransferUnits\n    for (const saveTransferUnit of saveFactory.transferUnits) {\n        const item = ITEMS[saveTransferUnit.item.name as keyof typeof ITEMS]\n        let output: Container | TransferContainer =\n            factoryContainers[saveTransferUnit.outputContainer]\n        if (output === undefined) {\n            output = factoryTransferContainers[saveTransferUnit.outputTransferContainer]\n        }\n        const transferUnit = factory.createTransferUnit(item, output, saveTransferUnit.id)\n        transferUnit.merged = saveTransferUnit.merged\n        transferUnit.requiredTransferRate = saveTransferUnit.requiredTransferRate\n\n        // Add inputs and rates\n        for (let i = 0; i < saveTransferUnit.inputs.length; i++) {\n            transferUnit.addInput(factoryContainers[saveTransferUnit.inputs[i]])\n            transferUnit.increaseTransferRate(\n                factoryContainers[saveTransferUnit.inputs[i]],\n                saveTransferUnit.rates[i],\n            )\n        }\n\n        factoryTransferUnits.push(transferUnit)\n    }\n\n    // set changed=false for all loaded factory nodes\n    for (const node of factory.containers) {\n        node.changed = false\n    }\n    for (const node of factory.industries) {\n        node.changed = false\n    }\n    for (const node of factory.transferUnits) {\n        node.changed = false\n    }\n    for (const node of factory.transferContainers) {\n        node.changed = false\n    }\n\n    // Add FactoryNodes\n    for (const saveNode of saveFactory.nodes) {\n        const item = ITEMS[saveNode.item.name as keyof typeof ITEMS]\n        let node: FactoryNode\n        if (isOre(item)) {\n            node = factory.createOreNode(item)\n        } else {\n            node = factory.createProductionNode(item)\n        }\n        node.outputRate = saveNode.outputRate\n        node.maintainedOutput = saveNode.maintainedOutput\n\n        for (let i = 0; i < saveNode.relayRouteContainers.length; i++) {\n            const relayRoute: RelayRoute = {\n                container: factoryContainers[saveNode.relayRouteContainers[i]],\n                transferUnit: factoryTransferUnits[saveNode.relayRouteTransferUnits[i]],\n            }\n            node.relayRoutes.push(relayRoute)\n        }\n\n        if (isProductionNode(node)) {\n            for (let i = 0; i < saveNode.dumpRouteContainers.length; i++) {\n                const dumpRoute: DumpRoute = {\n                    relayRoutes: saveNode.dumpRouteRelays[i].map(\n                        (idx: number) => node.relayRoutes[idx],\n                    ),\n                    container: factoryContainers[saveNode.dumpRouteContainers[i]],\n                    industries: saveNode.dumpRouteIndustries[i].map(\n                        (idx: number) => factoryIndustries[idx],\n                    ),\n                }\n                node.dumpRoutes.push(dumpRoute)\n            }\n        }\n        factoryNodes.push(node)\n    }\n\n    // Link nodes\n    for (const [i, saveNode] of saveFactory.nodes.entries()) {\n        for (const consumer of saveNode.consumers) {\n            factoryNodes[i].addConsumer(factoryNodes[consumer] as ProductionNode)\n        }\n    }\n\n    return factory\n}\n","import * as React from \"react\"\nimport { renderToStaticMarkup } from \"react-dom/server\"\nimport { Button, Space } from \"antd\"\nimport { UncontrolledReactSVGPanZoom } from \"react-svg-pan-zoom\"\nimport { FONTSIZE, FactoryVisualizationComponentProps } from \"./render-factory\"\nimport { FactoryInstruction } from \"./generate-instructions\"\n\nconst MAX_IMAGE_SIZE = 12500\n\n/**\n * Component for visualizing factory graph as a large map\n * @param props {@link FactoryVisualizationComponentProps}\n */\nexport function FactoryMap({ instructions }: FactoryVisualizationComponentProps) {\n    // get inner SVG\n    const [innerSVG, width, height] = React.useMemo(() => generateInnerSVG(instructions), [\n        instructions,\n    ])\n\n    function preparePNGDownload() {\n        const canvas = document.createElement(\"canvas\")\n        let scale = 1.0\n        let scaleWidth = width\n        let scaleHeight = height\n        if (scaleWidth > MAX_IMAGE_SIZE) {\n            scaleHeight *= MAX_IMAGE_SIZE / scaleWidth\n            scaleWidth *= MAX_IMAGE_SIZE / scaleWidth\n        }\n        if (scaleHeight > MAX_IMAGE_SIZE) {\n            scaleWidth *= MAX_IMAGE_SIZE / scaleHeight\n            scaleHeight *= MAX_IMAGE_SIZE / scaleHeight\n        }\n        canvas.width = scaleWidth\n        canvas.height = scaleHeight\n        const ctx = canvas.getContext(\"2d\")!\n        const svg = (\n            <svg\n                xmlns=\"http://www.w3.org/2000/svg\"\n                height={height}\n                width={width}\n                style={{ backgroundColor: \"white\" }}\n            >\n                {innerSVG}\n            </svg>\n        )\n        const svgBlob = new Blob([renderToStaticMarkup(svg)], {\n            type: \"image/svg+xml;charset=utf-8\",\n        })\n        const DOMURL = window.URL || window.webkitURL\n        const svgURL = DOMURL.createObjectURL(svgBlob)\n        const img = new Image()\n        img.onload = () => {\n            ctx.drawImage(img, 0, 0, scaleWidth, scaleHeight)\n            DOMURL.revokeObjectURL(svgURL)\n            triggerPNGDownload(canvas)\n        }\n        img.src = svgURL\n    }\n\n    function triggerPNGDownload(canvas: HTMLCanvasElement) {\n        const imgURI = canvas.toDataURL(\"image/png\")\n        const link = document.createElement(\"a\")\n        link.download = \"factory-map.png\"\n        link.href = imgURI\n        document.body.appendChild(link)\n        link.click()\n        link.remove()\n        canvas.remove()\n    }\n\n    return (\n        <React.Fragment>\n            <br />\n            <Space>\n                <Button onClick={preparePNGDownload}>Download Image as PNG</Button>\n                <Button\n                    href={`data:image/svg+xml,${encodeURIComponent(\n                        renderToStaticMarkup(\n                            <svg\n                                xmlns=\"http://www.w3.org/2000/svg\"\n                                height={height}\n                                width={width}\n                                style={{ backgroundColor: \"white\" }}\n                            >\n                                {innerSVG}\n                            </svg>,\n                        ),\n                    )}`}\n                    download=\"factory-map.svg\"\n                >\n                    Download Image as SVG\n                </Button>\n            </Space>\n            <div style={{ border: \"1px solid black\", width: 0.9 * window.innerWidth + 2 }}>\n                <UncontrolledReactSVGPanZoom\n                    width={0.9 * window.innerWidth}\n                    height={0.9 * window.innerHeight}\n                    defaultTool=\"pan\"\n                >\n                    <svg height={height} width={width}>\n                        {innerSVG}\n                    </svg>\n                </UncontrolledReactSVGPanZoom>\n            </div>\n        </React.Fragment>\n    )\n}\n\n/**\n * Generate SVG inner components, determine SVG dimensions\n * @param instructions the Factory instructions\n */\nexport function generateInnerSVG(\n    instructions: FactoryInstruction[],\n): [JSX.Element, number, number] {\n    // keep track of edges of each section\n    let start_x = 100\n    let start_y = 100\n\n    // keep track of the top-left corner where we are currently placing items\n    let x = start_x\n    let y = start_y\n\n    // keep track of maximum width and height of instructions\n    let max_x = start_x\n    let max_y = start_y\n\n    // keep track of the index of the first instruction in this section\n    let section_i = 0\n\n    // keep track of the maxInputWidth of the first instruction in each section\n    let maxInputWidth = instructions[0].maxInputWidth\n\n    const elements: JSX.Element[] = []\n    for (const [instruction_i, instruction] of instructions.entries()) {\n        const translate =\n            \"translate(\" + (x + maxInputWidth - instruction.maxInputWidth) + \",\" + y + \")\"\n        const element = (\n            <g key={instruction.name + \"group\"} transform={translate}>\n                {instruction.render()}\n            </g>\n        )\n        elements.push(element)\n\n        y += instruction.height\n        max_y = Math.max(y, max_y)\n\n        // check if we've reached the end of this section\n        let endSection = false\n        let endFactory = false\n        let sectionWidth = 0\n        let nextInstruction: FactoryInstruction | undefined\n        if (instruction_i < instructions.length - 1) {\n            nextInstruction = instructions[instruction_i + 1]\n            if (nextInstruction.section !== instruction.section) {\n                endSection = true\n            }\n        } else {\n            // end of factory\n            endSection = true\n            endFactory = true\n        }\n\n        // Add section title\n        if (endSection) {\n            //end of section\n            sectionWidth = Math.max(\n                ...instructions\n                    .slice(section_i, instruction_i + 1)\n                    .map((instruction) => instruction.width),\n            )\n            const translate = \"translate(\" + (x + sectionWidth / 2) + \",\" + start_y / 2 + \")\"\n            const element = (\n                <g key={\"sectionheader\" + section_i} transform={translate}>\n                    <text\n                        x={0}\n                        y={0}\n                        fill=\"black\"\n                        fontSize={2 * FONTSIZE}\n                        fontWeight=\"bold\"\n                        dominantBaseline=\"middle\"\n                        textAnchor=\"middle\"\n                    >\n                        <tspan x=\"0\" dy=\"1em\">\n                            {instruction.header1}\n                        </tspan>\n                        <tspan x=\"0\" dy=\"1em\">\n                            {instruction.header2}\n                        </tspan>\n                    </text>\n                </g>\n            )\n            elements.push(element)\n        }\n\n        if (endFactory) {\n            // save current x position\n            max_x =\n                x +\n                Math.max(\n                    ...instructions\n                        .slice(section_i, instruction_i + 1)\n                        .map((instruction) => instruction.width),\n                )\n        } else if (endSection) {\n            // move to next section\n            start_x += sectionWidth\n            start_y = 100\n            x = start_x\n            y = start_y\n            section_i = instruction_i + 1\n            maxInputWidth = nextInstruction!.maxInputWidth\n        }\n    }\n\n    const element = (\n        <React.Fragment>\n            <marker id=\"arrowhead\" markerWidth=\"5\" markerHeight=\"4\" refX=\"0\" refY=\"2\" orient=\"auto\">\n                <polygon points=\"0 0, 5 2, 0 4\" />\n            </marker>\n            {elements}\n        </React.Fragment>\n    )\n\n    return [element, max_x, max_y]\n}\n","import * as React from \"react\"\nimport { Button, Row, Col, Table, Space, Divider, Popover } from \"antd\"\nimport { Category, Tier, Item, CONTAINERS_ASCENDING_BY_CAPACITY, getRequiredOres } from \"../items\"\nimport { FactoryGraph } from \"../graph\"\nimport { FactoryState } from \"./factory\"\nimport { serialize } from \"../serialize\"\nimport { FactoryInstruction, sortName } from \"./generate-instructions\"\nimport { FactoryMap } from \"./factory-map\"\nimport { Container } from \"../container\"\nimport { TransferContainer } from \"../transfer-container\"\nconst example = require(\"../assets/example.png\")\n\nenum VisualizationState {\n    LIST = \"list\",\n    INSTRUCTIONS = \"instructions\",\n    MAP = \"map\",\n}\n\n// order that the factory is visualized\nexport const CATEGORY_ORDER = [\n    Category.ORE,\n    Category.PURE,\n    Category.CATALYST,\n    Category.PRODUCT,\n    Category.STRUCTURAL_PART,\n    Category.INTERMEDIARY_PART,\n    Category.COMPLEX_PART,\n    Category.EXCEPTIONAL_PART,\n    Category.FUNCTIONAL_PART,\n    Category.SCRAP,\n    Category.PURE_HONEYCOMB,\n    Category.PRODUCT_HONEYCOMB,\n    Category.FUEL,\n    Category.WARP_CELLS,\n    Category.AMMO,\n    Category.COMBAT_ELEMENT,\n    Category.FURNITURE_AND_APPLIANCES_ELEMENT,\n    Category.INDUSTRY_AND_INFRASTRUCTURE_ELEMENT,\n    Category.PILOTING_ELEMENT,\n    Category.PLANET_ELEMENT,\n    Category.SYSTEMS_ELEMENT,\n]\n\nexport const TIER_ORDER = [\n    Tier.GAS,\n    Tier.BASIC,\n    Tier.UNCOMMON,\n    Tier.ADVANCED,\n    Tier.RARE,\n    Tier.EXOTIC,\n]\n\n// industry labels\nexport const INDUSTRYLABELS: { [key: string]: string } = {\n    \"Assembly Line XS\": \"XS\",\n    \"Assembly Line S\": \"S\",\n    \"Assembly Line M\": \"M\",\n    \"Assembly Line L\": \"L\",\n    \"Assembly Line XL\": \"XL\",\n    \"3D Printer M\": \"3D\",\n    \"Chemical Industry M\": \"Che\",\n    \"Electronics Industry M\": \"Ele\",\n    \"Glass Furnace M\": \"Gla\",\n    \"Metalwork Industry M\": \"Met\",\n    \"Recycler M\": \"Rec\",\n    \"Refiner M\": \"Ref\",\n    \"Smelter M\": \"Sme\",\n}\n\n// Full tier names\nconst TIER = [\"\", \"\", \"\", \"Uncommon \", \"Advanced \", \"Rare \"]\n\n// Abbreviated tier labels\nexport const TIERLABELS: { [key: number]: string } = {\n    0: \"\",\n    1: \"\",\n    2: \"\",\n    3: \"Unc \",\n    4: \"Adv \",\n    5: \"Rare \",\n}\n\n// container labels\nexport const CONTAINERLABELS: { [key: string]: string } = {\n    \"Container XS\": \"XS\",\n    \"Container S\": \"S\",\n    \"Container M\": \"M\",\n    \"Container L\": \"L\",\n    \"Container XL\": \"XL\",\n    \"Expanded Container XL\": \"EXL\",\n}\n\n// The size (in pixels) of a node item in the visualization\nexport const SIZE = 60\n\n// The size (in pt) of the font\nexport const FONTSIZE = 10\n\n// Spacing between link lines\nexport const LINKSPACING = 1.1 * FONTSIZE\n\n/**\n * Generate string representation of required container size(s)\n */\nexport function containerLabel(container: Container | TransferContainer) {\n    let labels = []\n\n    // Loop over container sizes from large to small\n    if (CONTAINERS_ASCENDING_BY_CAPACITY.length < 1) {\n        throw new Error(\"CONTAINERS_ASCENDING_BY_CAPACITY is empty\")\n    }\n    for (let i = CONTAINERS_ASCENDING_BY_CAPACITY.length - 1; i >= 0; i--) {\n        const containerCount = container.containers.reduce(\n            (total, current) =>\n                current === CONTAINERS_ASCENDING_BY_CAPACITY[i].name ? total + 1 : total,\n            0,\n        )\n        if (containerCount > 1) {\n            labels.push(containerCount + CONTAINERLABELS[CONTAINERS_ASCENDING_BY_CAPACITY[i].name])\n        } else if (containerCount > 0) {\n            labels.push(CONTAINERLABELS[CONTAINERS_ASCENDING_BY_CAPACITY[i].name])\n        }\n    }\n    return labels.join(\"+\")\n}\n\n/**\n * Properties of the FactoryVisualization components\n */\nexport interface FactoryVisualizationComponentProps {\n    // the factory instructions\n    instructions: FactoryInstruction[]\n}\n\n/**\n * Properties of the FactoryVisualization components\n */\nexport interface FactoryVisualizationProps extends FactoryVisualizationComponentProps {\n    // the factory graph\n    factory: FactoryGraph | undefined\n\n    /**\n     * Set the factory\n     * @param factory the FactoryGraph\n     */\n    setFactory: (factory: FactoryGraph | undefined) => void\n\n    // the starting factory graph\n    startingFactory: FactoryGraph | undefined\n\n    /**\n     * Set the parent factory state\n     * @param state the FactoryState\n     */\n    setFactoryState: (state: FactoryState) => void\n\n    // Items selected to build\n    selection: Item[]\n\n    // ore prices\n    orePrices: { [key: string]: number }\n}\n\n/**\n * Component for visualizing factory graph\n * @param props {@link FactoryVisualizationProps}\n */\nexport function FactoryVisualization({\n    factory,\n    setFactory,\n    startingFactory,\n    setFactoryState,\n    instructions,\n    selection,\n    orePrices,\n}: FactoryVisualizationProps) {\n    // The state of the visualization\n    const [visualizationState, setVisualizationState] = React.useState<VisualizationState>()\n    // Flag to show the legend\n    const [showLegend, setShowLegend] = React.useState<boolean>(false)\n\n    // Scroll to top on render\n    React.useEffect(() => {\n        window.scrollTo(0, 0)\n    })\n\n    let content = null\n    switch (visualizationState) {\n        default:\n            // get count of industry, schematic, and container types\n            const industryCount: { [key: string]: number } = {}\n            let totalIndustries = 0\n            const containerCount: { [key: string]: number } = {}\n            let totalContainers = 0\n            const schematicCount: { [key: string]: number } = {}\n\n            // Get ore values\n            const requiredOres: { [key: string]: { [key: string]: number } } = {}\n            const oreValues: { [key: string]: number } = {}\n\n            if (factory !== undefined) {\n                Array.from(factory.industries).map((node) => {\n                    const industry = TIER[node.item.tier] + node.recipe.industry\n                    totalIndustries += 1\n                    if (industryCount[industry] === undefined) {\n                        industryCount[industry] = 0\n                    }\n                    industryCount[industry] += 1\n                    if (schematicCount[node.item.name] === undefined) {\n                        schematicCount[node.item.name] = 0\n                    }\n                    schematicCount[node.item.name] += 1\n                })\n                industryCount[\"Transfer Unit\"] = Array.from(factory.transferUnits)\n                    .filter((transferUnit) => !transferUnit.merged)\n                    .map((transferUnit) => transferUnit.number)\n                    .reduce((total, current) => total + current, 0)\n                totalIndustries += Array.from(factory.transferUnits).filter(\n                    (transferUnit) => !transferUnit.merged,\n                ).length\n\n                Array.from(factory.containers)\n                    .filter((container) => !container.merged)\n                    .map((container) => {\n                        // count container hubs\n                        if (container.containers.length > 1) {\n                            if (containerCount[\"Container Hub\"] === undefined) {\n                                containerCount[\"Container Hub\"] = 0\n                            }\n                            containerCount[\"Container Hub\"] += 1\n                        }\n                        for (const containerSize of container.containers) {\n                            totalContainers += 1\n                            if (containerCount[containerSize] === undefined) {\n                                containerCount[containerSize] = 0\n                            }\n                            containerCount[containerSize] += 1\n                        }\n                    })\n                Array.from(factory.transferContainers).map((container) => {\n                    for (const containerSize of container.containers) {\n                        totalContainers += 1\n                        if (containerCount[containerSize] === undefined) {\n                            containerCount[containerSize] = 0\n                        }\n                        containerCount[containerSize] += 1\n                    }\n                })\n\n                // get ore requirements per item\n                selection.map((item) => {\n                    const ores = getRequiredOres(item, requiredOres, factory.talentLevels)\n                    requiredOres[item.name] = ores\n                })\n\n                // get ore values per item\n                selection.map((item) => {\n                    oreValues[item.name] = 0\n                    Object.keys(requiredOres[item.name]).map((ore, index) => {\n                        oreValues[item.name] += orePrices[ore] * requiredOres[item.name][ore]\n                    })\n                })\n            }\n\n            // Save industry table columns and data\n            const industryColumns = [\n                {\n                    title: \"Industry\",\n                    dataIndex: \"industry\",\n                    key: \"industry\",\n                },\n                {\n                    title: \"Count\",\n                    dataIndex: \"count\",\n                    key: \"count\",\n                },\n            ]\n            const industryData: {}[] = []\n            Object.keys(industryCount)\n                .sort()\n                .map((key) =>\n                    industryData.push({\n                        key: industryData.length,\n                        industry: key,\n                        count: industryCount[key],\n                    }),\n                )\n\n            // Save container table columns and data\n            const containerColumns = [\n                {\n                    title: \"Container\",\n                    dataIndex: \"container\",\n                    key: \"container\",\n                },\n                {\n                    title: \"Count\",\n                    dataIndex: \"count\",\n                    key: \"count\",\n                },\n            ]\n            const containerData: {}[] = []\n            Object.keys(containerCount)\n                .sort()\n                .map((key) =>\n                    containerData.push({\n                        key: containerData.length,\n                        container: key,\n                        count: containerCount[key],\n                    }),\n                )\n\n            // Save schematic table columns and data\n            const schematicColumns = [\n                {\n                    title: \"Schematic\",\n                    dataIndex: \"schematic\",\n                    key: \"schematic\",\n                },\n                {\n                    title: \"Count\",\n                    dataIndex: \"count\",\n                    key: \"count\",\n                },\n            ]\n            const schematicData: {}[] = []\n            Object.keys(schematicCount)\n                .sort()\n                .map((key) =>\n                    schematicData.push({\n                        key: schematicData.length,\n                        schematic: key,\n                        count: schematicCount[key],\n                    }),\n                )\n\n            // Save ore value table columns and data\n            const oreValueColumns = [\n                {\n                    title: \"Item\",\n                    dataIndex: \"item\",\n                    key: \"item\",\n                    render: (value: string) => {\n                        const content = (\n                            <div>\n                                {Object.keys(requiredOres[value]).map((ore) => (\n                                    <p key={ore}>\n                                        {ore +\n                                            \": \" +\n                                            Math.round(requiredOres[value][ore]) +\n                                            \" @ \" +\n                                            Math.round(orePrices[ore]) +\n                                            \" quanta/L = \" +\n                                            Math.round(requiredOres[value][ore] * orePrices[ore]) +\n                                            \" quanta\"}\n                                    </p>\n                                ))}\n                            </div>\n                        )\n                        return (\n                            <Popover\n                                placement=\"topLeft\"\n                                title={value}\n                                content={content}\n                                trigger=\"hover\"\n                            >\n                                <a>{value}</a>\n                            </Popover>\n                        )\n                    },\n                },\n                {\n                    title: \"Ore Value\",\n                    dataIndex: \"value\",\n                    key: \"value\",\n                    render: (value: number) => {\n                        if (isNaN(value)) {\n                            return \"Ore prices not set\"\n                        }\n                        return value\n                    },\n                },\n            ]\n            const oreValueData: {}[] = []\n            Object.keys(oreValues)\n                .sort()\n                .map((key) =>\n                    oreValueData.push({\n                        key: oreValueData.length,\n                        item: key,\n                        value: Math.round(oreValues[key]),\n                    }),\n                )\n\n            content = (\n                <React.Fragment>\n                    <Space>\n                        <Button\n                            onClick={() => setVisualizationState(VisualizationState.INSTRUCTIONS)}\n                        >\n                            Building Instructions\n                        </Button>\n                        <Button onClick={() => setVisualizationState(VisualizationState.MAP)}>\n                            Factory Map\n                        </Button>\n                    </Space>\n                    <Row gutter={16}>\n                        <Col span={6}>\n                            <h2>Industries ({totalIndustries})</h2>\n                            <Table\n                                columns={industryColumns}\n                                dataSource={industryData}\n                                pagination={false}\n                            />\n                        </Col>\n                        <Col span={6}>\n                            <h2>Containers ({totalContainers})</h2>\n                            <Table\n                                columns={containerColumns}\n                                dataSource={containerData}\n                                pagination={false}\n                            />\n                        </Col>\n                        <Col span={6}>\n                            <h2>Schematics</h2>\n                            <Table\n                                columns={schematicColumns}\n                                dataSource={schematicData}\n                                pagination={false}\n                            />\n                        </Col>\n                        <Col span={6}>\n                            <h2>Ore Values</h2>\n                            <Table\n                                columns={oreValueColumns}\n                                dataSource={oreValueData}\n                                pagination={false}\n                            />\n                        </Col>\n                    </Row>\n                </React.Fragment>\n            )\n            break\n        case VisualizationState.INSTRUCTIONS:\n            content = (\n                <React.Fragment>\n                    <Space>\n                        <Button onClick={() => setVisualizationState(VisualizationState.LIST)}>\n                            Factory Summary\n                        </Button>\n                        <Button onClick={() => setVisualizationState(VisualizationState.MAP)}>\n                            Factory Map\n                        </Button>\n                        {showLegend && (\n                            <Button onClick={() => setShowLegend(false)}>Hide Legend</Button>\n                        )}\n                        {!showLegend && (\n                            <Button onClick={() => setShowLegend(true)}>Show Legend</Button>\n                        )}\n                    </Space>\n                    {showLegend && (\n                        <React.Fragment>\n                            <br />\n                            <img src={example.default} width=\"600px\" />\n                        </React.Fragment>\n                    )}\n                    <br />\n                    <FactoryInstructions instructions={instructions} />\n                </React.Fragment>\n            )\n            break\n        case VisualizationState.MAP:\n            content = (\n                <React.Fragment>\n                    <Space>\n                        <Button onClick={() => setVisualizationState(VisualizationState.LIST)}>\n                            Factory Summary\n                        </Button>\n                        <Button\n                            onClick={() => setVisualizationState(VisualizationState.INSTRUCTIONS)}\n                        >\n                            Building Instructions\n                        </Button>\n                        {showLegend && (\n                            <Button onClick={() => setShowLegend(false)}>Hide Legend</Button>\n                        )}\n                        {!showLegend && (\n                            <Button onClick={() => setShowLegend(true)}>Show Legend</Button>\n                        )}\n                    </Space>\n                    {showLegend && (\n                        <React.Fragment>\n                            <br />\n                            <img src={example.default} width=\"600px\" />\n                        </React.Fragment>\n                    )}\n                    <br />\n                    <FactoryMap instructions={instructions} />\n                </React.Fragment>\n            )\n            break\n    }\n\n    return (\n        <React.Fragment>\n            <Button\n                onClick={() => {\n                    setFactory(startingFactory)\n                    setFactoryState(FactoryState.COUNT)\n                }}\n            >\n                Back\n            </Button>\n            <h2>Factory Generator Results</h2>\n            <Divider orientation=\"left\">Instructions</Divider>\n            <ul>\n                <li>\n                    Factory Summary: List the required industries, containers, schematics, and raw\n                    ore values of produced items.\n                </li>\n                <li>Download Factory as JSON: Save the factory to a file.</li>\n                <li>Building Instructions: Step-by-step instructions for building the factory.</li>\n                <li>Factory Map: Visualize the entire factory plan at once.</li>\n            </ul>\n            <Button\n                href={`data:text/json;charset=utf-8,${encodeURIComponent(serialize(factory!))}`}\n                download=\"factory.json\"\n            >\n                Download Factory as JSON\n            </Button>\n            <br />\n            <br />\n            {content}\n        </React.Fragment>\n    )\n}\n\n/**\n * Component for visualizing factory graph as building instructions\n * @param props {@link FactoryVisualizationComponentProps}\n */\nexport function FactoryInstructions({ instructions }: FactoryVisualizationComponentProps) {\n    // current building step\n    const [step, setStep] = React.useState<number>(0)\n\n    return (\n        <React.Fragment>\n            <br />\n            {step < instructions.length - 1 && (\n                <Button onClick={() => setStep(step + 1)}>Next Step</Button>\n            )}\n            {step > 0 && <Button onClick={() => setStep(step - 1)}>Previous Step</Button>}\n            <br />\n            <svg height={instructions[step].height} width={instructions[step].width}>\n                <marker\n                    id=\"arrowhead\"\n                    markerWidth=\"5\"\n                    markerHeight=\"4\"\n                    refX=\"0\"\n                    refY=\"2\"\n                    orient=\"auto\"\n                >\n                    <polygon points=\"0 0, 5 2, 0 4\" />\n                </marker>\n                <rect width=\"100%\" height=\"100%\" fill=\"lightgray\" />\n                {instructions[step].render()}\n            </svg>\n        </React.Fragment>\n    )\n}\n","import * as React from \"react\"\nimport { TransferContainer } from \"../transfer-container\"\nimport { sortName } from \"./generate-instructions\"\nimport { containerLabel, FONTSIZE, LINKSPACING, SIZE } from \"./render-factory\"\n\n/**\n * Instruction centered on a transfer container\n */\nexport class TransferContainerInstruction {\n    name: string\n    header1: string\n    header2: string\n\n    /**\n     * Create a new TransferContainerInstruction\n     * @param container TransferContainer that is the focal point of this instruction\n     * @param highlightDiff Highlight changed nodes\n     * @param section Section identifier\n     */\n    constructor(\n        readonly container: TransferContainer,\n        readonly highlightDiff: boolean,\n        readonly section: number,\n    ) {\n        this.name = container.name\n        this.header1 = \"Transfer\"\n        this.header2 = \"Container\"\n    }\n\n    /**\n     * Approximate the width of the longest input link name\n     */\n    get maxInputWidth(): number {\n        let maxInputWidth = 0\n        for (const producer of this.container.producers) {\n            for (const input of producer.inputs) {\n                maxInputWidth = Math.max(maxInputWidth, (FONTSIZE / 1.333) * input.name.length)\n            }\n        }\n        return maxInputWidth\n    }\n\n    /**\n     * Approximate the width of the longest output link name\n     */\n    get maxOutputWidth(): number {\n        let maxOutputWidth = 0\n        for (const consumer of this.container.consumers) {\n            maxOutputWidth = Math.max(maxOutputWidth, (FONTSIZE / 1.333) * consumer.name.length)\n        }\n        return maxOutputWidth\n    }\n\n    /**\n     * Approximate the width of this instruction SVG\n     */\n    get width(): number {\n        // -> industry -> container -> = 5x SIZE\n        // Add approximate width of longest input link and output link strings\n        let width = 5 * SIZE + this.maxInputWidth + this.maxOutputWidth\n        return width\n    }\n\n    /**\n     * Approximate the height of this instruction SVG\n     */\n    get height(): number {\n        // height is a little larger than 1.5*size of combined producers\n        let height = 0.75 * SIZE + 1.5 * SIZE * this.container.producers.size\n        return height\n    }\n\n    /**\n     * Generate SVG\n     */\n    render(): JSX.Element[] {\n        let elements: JSX.Element[] = []\n        let start_x = this.maxInputWidth\n        const start_y = 0.75 * SIZE\n\n        // Get producers and sort by name\n        const producers = Array.from(this.container.producers)\n        producers.sort((a, b) => sortName(a, b))\n\n        let element = null\n        let x = 0\n        let y = 0\n        let relayHeight = 1.5 * SIZE * this.container.producers.size\n\n        // Loop over producers\n        for (const [producer_i, producer] of producers.entries()) {\n            // Get input links and sort by name\n            const inputs = Array.from(producer.inputs)\n            inputs.sort((a, b) => sortName(a, b))\n\n            // Loop over input links\n            for (const [input_i, input] of inputs.entries()) {\n                x = start_x\n                y =\n                    start_y +\n                    1.5 * SIZE * producer_i +\n                    SIZE / 2 +\n                    LINKSPACING * (input_i - (inputs.length - 1) / 2)\n\n                // Add input link\n                element = (\n                    <text\n                        x={x}\n                        y={y}\n                        fill=\"black\"\n                        fontSize={FONTSIZE}\n                        dominantBaseline=\"middle\"\n                        textAnchor=\"end\"\n                        key={this.container.name + \"producer\" + producer_i + \"inputlink\" + input_i}\n                    >\n                        {input.name}\n                    </text>\n                )\n                elements.push(element)\n            }\n\n            x = start_x + SIZE\n            y = start_y + 1.5 * SIZE * producer_i\n\n            // add producer\n            element = (\n                <React.Fragment key={this.container.name + \"producer\" + producer_i}>\n                    <line\n                        x1={x - SIZE}\n                        y1={y + SIZE / 2}\n                        x2={x - 10}\n                        y2={y + SIZE / 2}\n                        stroke=\"#000\"\n                        strokeWidth=\"2\"\n                        markerEnd=\"url(#arrowhead)\"\n                    />\n                    <polygon\n                        points={`${x + SIZE / 2} ${y}, ${x + SIZE} ${y + SIZE / 2}, ${\n                            x + SIZE / 2\n                        } ${y + SIZE}, ${x} ${y + SIZE / 2}`}\n                        fill={this.highlightDiff && producer.changed ? \"magenta\" : \"gray\"}\n                        stroke=\"magenta\"\n                        strokeWidth=\"3\"\n                    />\n                    <text\n                        x={x + SIZE / 2}\n                        y={y + SIZE / 2}\n                        fill=\"black\"\n                        fontSize={1.0 * FONTSIZE}\n                        dominantBaseline=\"middle\"\n                        textAnchor=\"middle\"\n                    >\n                        {producer.number + \"xTU\"}\n                    </text>\n                    <text\n                        x={x + SIZE / 2}\n                        y={y - 5}\n                        fill=\"black\"\n                        fontSize={FONTSIZE}\n                        dominantBaseline=\"auto\"\n                        textAnchor=\"end\"\n                    >\n                        {producer.name}\n                    </text>\n                    <text\n                        x={x + SIZE}\n                        y={y + 0.75 * SIZE}\n                        fill=\"black\"\n                        fontSize={FONTSIZE}\n                        dominantBaseline=\"auto\"\n                        textAnchor=\"start\"\n                    >\n                        {this.container.maintain(producer.item)}\n                    </text>\n                    <line\n                        x1={x + SIZE}\n                        y1={y + SIZE / 2}\n                        x2={x + 1.5 * SIZE + 10}\n                        y2={y + SIZE / 2}\n                        stroke=\"#000\"\n                        strokeWidth=\"2\"\n                    />\n                    <line\n                        x1={x + 1.5 * SIZE + 10}\n                        y1={y + SIZE / 2}\n                        x2={x + 1.5 * SIZE + 10}\n                        y2={start_y + relayHeight / 2 - SIZE / 4}\n                        stroke=\"#000\"\n                        strokeWidth=\"2\"\n                    />\n                </React.Fragment>\n            )\n            elements.push(element)\n        }\n\n        // add container\n        x = start_x + 3 * SIZE\n        y = start_y + relayHeight / 2 - SIZE / 4\n        element = (\n            <React.Fragment key={this.container.name}>\n                <line\n                    x1={x - SIZE / 2 + 10}\n                    y1={y}\n                    x2={x - 10}\n                    y2={y}\n                    stroke=\"#000\"\n                    strokeWidth=\"2\"\n                    markerEnd=\"url(#arrowhead)\"\n                />\n                <rect\n                    x={x}\n                    y={y - SIZE / 2}\n                    width={SIZE}\n                    height={SIZE}\n                    fill={this.highlightDiff && this.container.changed ? \"red\" : \"gray\"}\n                    stroke={\"red\"}\n                    strokeWidth=\"3\"\n                />\n                <text\n                    x={x + SIZE / 2}\n                    y={y - SIZE / 2 - 5}\n                    fill=\"black\"\n                    fontSize={FONTSIZE}\n                    dominantBaseline=\"auto\"\n                    textAnchor=\"middle\"\n                >\n                    {this.container.id}\n                </text>\n                <text\n                    x={x + SIZE / 2}\n                    y={y}\n                    fill=\"black\"\n                    fontSize={1.0 * FONTSIZE}\n                    dominantBaseline=\"middle\"\n                    textAnchor=\"middle\"\n                >\n                    {containerLabel(this.container)}\n                </text>\n                <line\n                    x1={x + SIZE}\n                    y1={y}\n                    x2={x + 2 * SIZE - 10}\n                    y2={y}\n                    stroke=\"#000\"\n                    strokeWidth=\"2\"\n                    markerEnd=\"url(#arrowhead)\"\n                />\n            </React.Fragment>\n        )\n        elements.push(element)\n\n        // Get output links\n        const outputs = Array.from(this.container.consumers)\n        // Sort by name\n        outputs.sort((a, b) => sortName(a, b))\n\n        // Loop over output links\n        for (const [output_i, output] of outputs.entries()) {\n            x = start_x + 5 * SIZE\n            y =\n                start_y +\n                relayHeight / 2.0 -\n                SIZE / 4 +\n                LINKSPACING * (output_i - (outputs.length - 1) / 2)\n\n            // Add output link\n            const element = (\n                <text\n                    x={x}\n                    y={y}\n                    fill=\"black\"\n                    fontSize={FONTSIZE}\n                    dominantBaseline=\"middle\"\n                    textAnchor=\"start\"\n                    key={this.container.name + \"outputlink\" + output_i}\n                >\n                    {output.name}\n                </text>\n            )\n            elements.push(element)\n        }\n        return elements\n    }\n}\n","import * as React from \"react\"\nimport { DumpRoute, FactoryNode } from \"../graph\"\nimport { isIndustry } from \"../industry\"\nimport { isByproductTransferUnit, isCatalystBalancer, isTransferUnit } from \"../transfer-unit\"\nimport { sortName } from \"./generate-instructions\"\nimport {\n    containerLabel,\n    FONTSIZE,\n    INDUSTRYLABELS,\n    TIERLABELS,\n    LINKSPACING,\n    SIZE,\n} from \"./render-factory\"\n\n/**\n * Instruction centered on a transfer container\n */\nexport class NodeInstruction {\n    name: string\n\n    /**\n     * Create a new NodeInstruction\n     * @param node The factory node\n     * @param dumpGroup The dump routes included in this instruction\n     * @param highlightDiff Highlight changed nodes\n     * @section Section identifier\n     * @header1 Header for this section\n     * @header2 Header for this section\n     */\n    constructor(\n        readonly node: FactoryNode,\n        readonly dumpGroup: DumpRoute[],\n        readonly highlightDiff: boolean,\n        readonly section: number,\n        readonly header1: string,\n        readonly header2: string,\n    ) {\n        this.name = dumpGroup[0].container.name\n    }\n\n    /**\n     * Approximate the width of the longest input link name\n     */\n    get maxInputWidth(): number {\n        let maxInputWidth = 0\n        for (const dumpRoute of this.dumpGroup) {\n            for (const producer of dumpRoute.container.producers) {\n                for (const input of producer.inputs) {\n                    maxInputWidth = Math.max(maxInputWidth, (FONTSIZE / 1.333) * input.name.length)\n                }\n            }\n        }\n        return maxInputWidth\n    }\n\n    /**\n     * Approximate the width of the longest output link name\n     */\n    get maxOutputWidth(): number {\n        let maxOutputWidth = 0\n        for (const dumpRoute of this.dumpGroup) {\n            for (const relayRoute of dumpRoute.relayRoutes) {\n                for (const consumer of relayRoute.container.consumers) {\n                    maxOutputWidth = Math.max(\n                        maxOutputWidth,\n                        (FONTSIZE / 1.333) * consumer.name.length,\n                    )\n                }\n            }\n        }\n        return maxOutputWidth\n    }\n\n    /**\n     * Approximate the width of this instruction SVG\n     */\n    get width(): number {\n        // <input name> -> industry -> container -> transfer -> container -> <output name>\n        // = 9x SIZE + input and output lengths\n        let width = 9 * SIZE + this.maxInputWidth + this.maxOutputWidth\n        return width\n    }\n\n    /**\n     * Approximate the height of this instruction SVG based on the number of producers\n     */\n    get producerHeight(): number {\n        let height = SIZE * (this.dumpGroup.length - 1)\n        const numProducers = this.dumpGroup\n            .map((dumpRoute) => dumpRoute.container.incomingLinkCount)\n            .reduce((total, current) => total + current, 0)\n        height += 1.5 * SIZE * numProducers\n        return height\n    }\n\n    /**\n     * Approximate the height of this instruction SVG based on the number of relays\n     */\n    get relayHeight(): number {\n        let numRelays = this.dumpGroup[0].relayRoutes.length\n        return 2.5 * SIZE * numRelays\n    }\n\n    /**\n     * Approximate the height of this instruction SVG\n     */\n    get height(): number {\n        return SIZE + Math.max(this.producerHeight, this.relayHeight)\n    }\n\n    /**\n     * Generate SVG\n     */\n    render(): JSX.Element[] {\n        let elements: JSX.Element[] = []\n        let start_x = this.maxInputWidth\n        const start_y = 0.75 * SIZE\n\n        // if the producers are taller than the relays, then start the producers at the top\n        // and offset the relays from the center\n        let dumpStart_y = start_y\n        let relayStart_y = start_y + this.producerHeight / 2.0 - this.relayHeight / 2.0\n        if (this.producerHeight < this.relayHeight) {\n            // Otherwise, start the relays at the top and offset the producers from the center\n            dumpStart_y = start_y + this.relayHeight / 2.0 - this.producerHeight / 2.0\n            relayStart_y = start_y\n        }\n\n        let x = 0\n        let y = 0\n        let lastDump_y = []\n        let element = null\n\n        // Loop over dump Routes\n        for (const dumpRoute of this.dumpGroup) {\n            // Get producers and sort by name\n            const producers = Array.from(dumpRoute.container.producers)\n            producers.sort((a, b) => sortName(a, b))\n\n            const dumpHeight = 1.5 * SIZE * producers.length\n\n            // Loop over producers\n            for (const [producer_i, producer] of producers.entries()) {\n                // Get input links\n                const inputs = Array.from(producer.inputs)\n                // Sort by name\n                inputs.sort((a, b) => sortName(a, b))\n\n                // Loop over input links\n                for (const [input_i, input] of inputs.entries()) {\n                    x = start_x\n                    y =\n                        dumpStart_y +\n                        producer_i * 1.5 * SIZE +\n                        SIZE / 2 +\n                        LINKSPACING * (input_i - (inputs.length - 1) / 2)\n\n                    // Add input link\n                    element = (\n                        <text\n                            x={x}\n                            y={y}\n                            fill=\"black\"\n                            fontSize={FONTSIZE}\n                            dominantBaseline=\"middle\"\n                            textAnchor=\"end\"\n                            key={\n                                dumpRoute.container.name +\n                                \"producer\" +\n                                producer_i +\n                                \"inputlink\" +\n                                input_i\n                            }\n                        >\n                            {input.name}\n                        </text>\n                    )\n                    elements.push(element)\n                }\n\n                x = start_x + SIZE\n                y = dumpStart_y + producer_i * 1.5 * SIZE\n\n                // add producer\n                element = (\n                    <React.Fragment key={dumpRoute.container.name + \"producer\" + producer_i}>\n                        <line\n                            x1={x - SIZE}\n                            y1={y + SIZE / 2}\n                            x2={x - 10}\n                            y2={y + SIZE / 2}\n                            stroke=\"#000\"\n                            strokeWidth=\"2\"\n                            markerEnd=\"url(#arrowhead)\"\n                        />\n                        {isTransferUnit(producer) && (\n                            <polygon\n                                points={`${x + SIZE / 2} ${y}, ${x + SIZE} ${y + SIZE / 2}, ${\n                                    x + SIZE / 2\n                                } ${y + SIZE}, ${x} ${y + SIZE / 2}`}\n                                fill={this.highlightDiff && producer.changed ? \"magenta\" : \"gray\"}\n                                stroke=\"magenta\"\n                                strokeWidth=\"3\"\n                            />\n                        )}\n                        {isIndustry(producer) && (\n                            <circle\n                                cx={x + SIZE / 2}\n                                cy={y + SIZE / 2}\n                                r={SIZE / 2}\n                                fill={this.highlightDiff && producer.changed ? \"green\" : \"gray\"}\n                                stroke=\"green\"\n                                strokeWidth=\"3\"\n                            />\n                        )}\n                        <text\n                            x={x + SIZE / 2}\n                            y={y + SIZE / 2}\n                            fill=\"black\"\n                            fontSize={1.0 * FONTSIZE}\n                            dominantBaseline=\"middle\"\n                            textAnchor=\"middle\"\n                        >\n                            {isIndustry(producer) &&\n                                TIERLABELS[producer.item.tier] +\n                                    INDUSTRYLABELS[producer.recipe.industry]}\n                            {isTransferUnit(producer) && producer.number + \"xTU\"}\n                        </text>\n                        <text\n                            x={x + SIZE / 2}\n                            y={y - 5}\n                            fill=\"black\"\n                            fontSize={FONTSIZE}\n                            dominantBaseline=\"auto\"\n                            textAnchor=\"middle\"\n                        >\n                            {producer.id}\n                        </text>\n                        <line\n                            x1={x + SIZE}\n                            y1={y + SIZE / 2}\n                            x2={x + SIZE + 5}\n                            y2={y + SIZE / 2}\n                            stroke=\"#000\"\n                            strokeWidth=\"2\"\n                        />\n                        <line\n                            x1={x + SIZE + 5}\n                            y1={y + SIZE / 2}\n                            x2={x + SIZE + 5}\n                            y2={dumpStart_y + dumpHeight / 2 - SIZE / 4}\n                            stroke=\"#000\"\n                            strokeWidth=\"2\"\n                        />\n                    </React.Fragment>\n                )\n                elements.push(element)\n            }\n\n            // add dump container\n            x = start_x + 3 * SIZE\n            y = dumpStart_y + dumpHeight / 2 - SIZE / 4\n            lastDump_y.push(y)\n            let ingress = dumpRoute.container.ingress(dumpRoute.container.item)\n            let egress = dumpRoute.container.egress(dumpRoute.container.item)\n            let steadyStateEgress = dumpRoute.container.steadyStateEgress(dumpRoute.container.item)\n            let outputRate = dumpRoute.container.outputRate\n            let unit = \"sec\"\n            if (steadyStateEgress < 1) {\n                ingress *= 60.0\n                egress *= 60.0\n                steadyStateEgress *= 60.0\n                outputRate *= 60.0\n                unit = \"min\"\n            }\n            if (steadyStateEgress < 1) {\n                ingress *= 60.0\n                egress *= 60.0\n                steadyStateEgress *= 60.0\n                outputRate *= 60.0\n                unit = \"hour\"\n            }\n            if (steadyStateEgress < 1) {\n                ingress *= 24.0\n                egress *= 24.0\n                steadyStateEgress *= 24.0\n                outputRate *= 24.0\n                unit = \"day\"\n            }\n            ingress = Math.round(ingress * 100) / 100\n            egress = Math.round(egress * 100) / 100\n            steadyStateEgress = Math.round(steadyStateEgress * 100) / 100\n            outputRate = Math.round(outputRate * 100) / 100\n            element = (\n                <React.Fragment key={dumpRoute.container.name}>\n                    {dumpRoute.container.producers.size > 0 && (\n                        <React.Fragment>\n                            <line\n                                x1={x - SIZE + 5}\n                                y1={y}\n                                x2={x - 10}\n                                y2={y}\n                                stroke=\"#000\"\n                                strokeWidth=\"2\"\n                                markerEnd=\"url(#arrowhead)\"\n                            />\n                            <text\n                                x={x - 2}\n                                y={y - 5}\n                                fill=\"green\"\n                                fontSize={FONTSIZE}\n                                dominantBaseline=\"auto\"\n                                textAnchor=\"end\"\n                            >\n                                {ingress + \"/\" + unit}\n                            </text>\n                        </React.Fragment>\n                    )}\n                    <rect\n                        x={x}\n                        y={y - SIZE / 2}\n                        width={SIZE}\n                        height={SIZE}\n                        fill={this.highlightDiff && dumpRoute.container.changed ? \"red\" : \"gray\"}\n                        stroke={outputRate > 0 ? \"blue\" : \"red\"}\n                        strokeWidth=\"3\"\n                    />\n                    <text\n                        x={x + SIZE / 2}\n                        y={y - SIZE / 2 - 5}\n                        fill=\"black\"\n                        fontSize={FONTSIZE}\n                        dominantBaseline=\"auto\"\n                        textAnchor=\"middle\"\n                    >\n                        {dumpRoute.container.id}\n                    </text>\n                    <text\n                        x={x + SIZE / 2}\n                        y={y + SIZE / 2 + 5}\n                        fill=\"black\"\n                        fontSize={FONTSIZE}\n                        dominantBaseline=\"hanging\"\n                        textAnchor=\"middle\"\n                    >\n                        {Math.ceil(dumpRoute.container.maintain)}\n                    </text>\n                    <text\n                        x={x + SIZE / 2}\n                        y={y}\n                        fill=\"black\"\n                        fontSize={1.0 * FONTSIZE}\n                        dominantBaseline=\"middle\"\n                        textAnchor=\"middle\"\n                    >\n                        {containerLabel(dumpRoute.container)}\n                    </text>\n                    {dumpRoute.container.consumers.size > 0 && (\n                        <React.Fragment>\n                            <line\n                                x1={x + SIZE}\n                                y1={y}\n                                x2={x + 2 * SIZE - 15}\n                                y2={y}\n                                stroke=\"#000\"\n                                strokeWidth=\"2\"\n                            />\n                            <text\n                                x={x + SIZE + 2}\n                                y={y - 5}\n                                fill=\"red\"\n                                fontSize=\"10\"\n                                dominantBaseline=\"auto\"\n                                textAnchor=\"start\"\n                            >\n                                {egress + \"/\" + unit}\n                            </text>\n                            <text\n                                x={x + SIZE + 2}\n                                y={y + 10}\n                                fill=\"blue\"\n                                fontSize=\"10\"\n                                dominantBaseline=\"auto\"\n                                textAnchor=\"start\"\n                            >\n                                {steadyStateEgress + \"/\" + unit}\n                            </text>\n                        </React.Fragment>\n                    )}\n                </React.Fragment>\n            )\n            elements.push(element)\n\n            // Add byproduct consumers from this dump container\n            let numByproductConsumers = 0\n            for (const consumer of dumpRoute.container.consumers) {\n                if (\n                    isTransferUnit(consumer) &&\n                    (isByproductTransferUnit(consumer) || isCatalystBalancer(consumer))\n                ) {\n                    element = (\n                        <React.Fragment\n                            key={dumpRoute.container.name + \"byproduct\" + consumer.name}\n                        >\n                            <text\n                                x={x + 1.5 * SIZE}\n                                y={y + SIZE / 2 + 30 + 1.1 * FONTSIZE * numByproductConsumers}\n                                fill=\"black\"\n                                fontSize=\"10\"\n                                dominantBaseline=\"auto\"\n                                textAnchor=\"end\"\n                            >\n                                {consumer.name}\n                            </text>\n                        </React.Fragment>\n                    )\n                    elements.push(element)\n\n                    numByproductConsumers += 1\n                }\n            }\n            if (numByproductConsumers > 0) {\n                // Add arrow\n                element = (\n                    <React.Fragment key={dumpRoute.container.name + \"byproduct arrow\"}>\n                        <line\n                            x1={x + SIZE}\n                            y1={y + SIZE / 4}\n                            x2={x + 1.5 * SIZE - 10}\n                            y2={y + SIZE / 4}\n                            stroke=\"#000\"\n                            strokeWidth=\"2\"\n                            strokeDasharray=\"4\"\n                        />\n                        <line\n                            x1={x + 1.5 * SIZE - 10}\n                            y1={y + SIZE / 4}\n                            x2={x + 1.5 * SIZE - 10}\n                            y2={y + SIZE / 2 + 10}\n                            stroke=\"#000\"\n                            strokeWidth=\"2\"\n                            strokeDasharray=\"4\"\n                            markerEnd=\"url(#arrowhead)\"\n                        />\n                    </React.Fragment>\n                )\n                elements.push(element)\n            }\n\n            dumpStart_y += dumpHeight + SIZE\n        }\n\n        // Add relay transfer units and containers\n        let relayRoutes = this.dumpGroup[0].relayRoutes\n\n        // add item name\n        element = (\n            <text\n                key={relayRoutes[0].container.name + \"label\"}\n                x={start_x + 5.5 * SIZE}\n                y={0.5 * SIZE}\n                fill=\"black\"\n                fontSize={1.5 * FONTSIZE}\n                dominantBaseline=\"auto\"\n                textAnchor=\"middle\"\n                fontWeight=\"bold\"\n            >\n                {relayRoutes[0].container.item.name}\n            </text>\n        )\n        elements.push(element)\n\n        for (const relayRoute of relayRoutes) {\n            x = start_x + 5 * SIZE\n            y = relayStart_y + SIZE / 2\n\n            // add arrows from each dump container to transfer unit\n            for (const dump_y of lastDump_y) {\n                element = (\n                    <React.Fragment key={relayRoute.container.name + \"transfer lines \" + dump_y}>\n                        <line\n                            x1={x - 15}\n                            y1={dump_y}\n                            x2={x - 15}\n                            y2={y + SIZE / 2}\n                            stroke=\"#000\"\n                            strokeWidth=\"2\"\n                        />\n                        <line\n                            x1={x - 15}\n                            y1={y + SIZE / 2}\n                            x2={x - 10}\n                            y2={y + SIZE / 2}\n                            stroke=\"#000\"\n                            strokeWidth=\"2\"\n                            markerEnd=\"url(#arrowhead)\"\n                        />\n                    </React.Fragment>\n                )\n                elements.push(element)\n            }\n\n            // add transfer unit\n            element = (\n                <React.Fragment key={relayRoute.container.name + \"transfer\"}>\n                    <polygon\n                        points={`${x + SIZE / 2} ${y}, ${x + SIZE} ${y + SIZE / 2}, ${\n                            x + SIZE / 2\n                        } ${y + SIZE}, ${x} ${y + SIZE / 2}`}\n                        fill={\n                            this.highlightDiff && relayRoute.transferUnit.changed\n                                ? \"magenta\"\n                                : \"gray\"\n                        }\n                        stroke=\"magenta\"\n                        strokeWidth=\"3\"\n                    />\n                    <text\n                        x={x + SIZE / 2}\n                        y={y + SIZE / 2}\n                        fill=\"black\"\n                        fontSize={1.0 * FONTSIZE}\n                        dominantBaseline=\"middle\"\n                        textAnchor=\"middle\"\n                    >\n                        {relayRoute.transferUnit.number + \"xTU\"}\n                    </text>\n                    <text\n                        x={x + SIZE / 2}\n                        y={y - 5}\n                        fill=\"black\"\n                        fontSize={FONTSIZE}\n                        dominantBaseline=\"auto\"\n                        textAnchor=\"middle\"\n                    >\n                        {relayRoute.transferUnit.id}\n                    </text>\n                </React.Fragment>\n            )\n            elements.push(element)\n\n            // Add relay container\n            x = start_x + 7 * SIZE\n            y = relayStart_y + SIZE / 2\n            let ingress = relayRoute.container.ingress(relayRoute.container.item)\n            let egress = relayRoute.container.egress(relayRoute.container.item)\n            let steadyStateEgress = relayRoute.container.steadyStateEgress(\n                relayRoute.container.item,\n            )\n            let outputRate = relayRoute.container.outputRate\n            let unit = \"sec\"\n            if (steadyStateEgress < 1) {\n                ingress *= 60.0\n                egress *= 60.0\n                steadyStateEgress *= 60.0\n                outputRate *= 60.0\n                unit = \"min\"\n            }\n            if (steadyStateEgress < 1) {\n                ingress *= 60.0\n                egress *= 60.0\n                steadyStateEgress *= 60.0\n                outputRate *= 60.0\n                unit = \"hour\"\n            }\n            if (steadyStateEgress < 1) {\n                ingress *= 24.0\n                egress *= 24.0\n                steadyStateEgress *= 24.0\n                outputRate *= 24.0\n                unit = \"day\"\n            }\n            ingress = Math.round(ingress * 100) / 100\n            egress = Math.round(egress * 100) / 100\n            steadyStateEgress = Math.round(steadyStateEgress * 100) / 100\n            outputRate = Math.round(outputRate * 100) / 100\n            element = (\n                <React.Fragment key={relayRoute.container.name}>\n                    {relayRoute.container.producers.size > 0 && (\n                        <React.Fragment>\n                            <line\n                                x1={x - SIZE}\n                                y1={y + SIZE / 2}\n                                x2={x - 10}\n                                y2={y + SIZE / 2}\n                                stroke=\"#000\"\n                                strokeWidth=\"2\"\n                                markerEnd=\"url(#arrowhead)\"\n                            />\n                            <text\n                                x={x - 2}\n                                y={y + SIZE / 2 - 5}\n                                fill=\"green\"\n                                fontSize={FONTSIZE}\n                                dominantBaseline=\"auto\"\n                                textAnchor=\"end\"\n                            >\n                                {ingress + \"/\" + unit}\n                            </text>\n                        </React.Fragment>\n                    )}\n                    <rect\n                        x={x}\n                        y={y}\n                        width={SIZE}\n                        height={SIZE}\n                        fill={this.highlightDiff && relayRoute.container.changed ? \"red\" : \"gray\"}\n                        stroke={outputRate > 0 ? \"blue\" : \"red\"}\n                        strokeWidth=\"3\"\n                    />\n                    <text\n                        x={x + SIZE / 2}\n                        y={y - 5}\n                        fill=\"black\"\n                        fontSize={FONTSIZE}\n                        dominantBaseline=\"auto\"\n                        textAnchor=\"middle\"\n                    >\n                        {relayRoute.container.id}\n                    </text>\n                    <text\n                        x={x + SIZE / 2}\n                        y={y + SIZE + 5}\n                        fill=\"black\"\n                        fontSize={FONTSIZE}\n                        dominantBaseline=\"hanging\"\n                        textAnchor=\"middle\"\n                    >\n                        {Math.ceil(relayRoute.container.maintain)}\n                    </text>\n                    <text\n                        x={x + SIZE / 2}\n                        y={y + SIZE / 2}\n                        fill=\"black\"\n                        fontSize={1.0 * FONTSIZE}\n                        dominantBaseline=\"middle\"\n                        textAnchor=\"middle\"\n                    >\n                        {containerLabel(relayRoute.container)}\n                    </text>\n                    {relayRoute.container.consumers.size > 0 && (\n                        <React.Fragment>\n                            <line\n                                x1={x + SIZE}\n                                y1={y + SIZE / 2}\n                                x2={x + 2 * SIZE - 10}\n                                y2={y + SIZE / 2}\n                                stroke=\"#000\"\n                                strokeWidth=\"2\"\n                                markerEnd=\"url(#arrowhead)\"\n                            />\n                            <text\n                                x={x + SIZE + 2}\n                                y={y + SIZE / 2 - 5}\n                                fill=\"red\"\n                                fontSize=\"10\"\n                                dominantBaseline=\"auto\"\n                                textAnchor=\"start\"\n                            >\n                                {egress + \"/\" + unit}\n                            </text>\n                            <text\n                                x={x + SIZE + 2}\n                                y={y + SIZE / 2 + 10}\n                                fill=\"blue\"\n                                fontSize=\"10\"\n                                dominantBaseline=\"auto\"\n                                textAnchor=\"start\"\n                            >\n                                {steadyStateEgress + \"/\" + unit}\n                            </text>\n                        </React.Fragment>\n                    )}\n                </React.Fragment>\n            )\n            elements.push(element)\n\n            // Add relay output links\n            const outputs = Array.from(relayRoute.container.consumers)\n            // Sort by name\n            outputs.sort((a, b) => sortName(a, b))\n\n            // Loop over output links\n            for (const [output_i, output] of outputs.entries()) {\n                x = start_x + 9 * SIZE\n                y = relayStart_y + SIZE + LINKSPACING * (output_i - (outputs.length - 1) / 2)\n\n                // Add output link\n                const element = (\n                    <text\n                        x={x}\n                        y={y}\n                        fill=\"black\"\n                        fontSize={FONTSIZE}\n                        dominantBaseline=\"middle\"\n                        textAnchor=\"start\"\n                        key={relayRoute.container.name + \"outputlink\" + output_i}\n                    >\n                        {output.name}\n                    </text>\n                )\n                elements.push(element)\n            }\n            relayStart_y += 2.5 * SIZE\n        }\n        return elements\n    }\n}\n","import * as React from \"react\"\nimport { Container } from \"../container\"\nimport { isIndustry } from \"../industry\"\nimport { isByproductTransferUnit, isCatalystBalancer, isTransferUnit } from \"../transfer-unit\"\nimport { sortName } from \"./generate-instructions\"\nimport {\n    containerLabel,\n    FONTSIZE,\n    INDUSTRYLABELS,\n    TIERLABELS,\n    LINKSPACING,\n    SIZE,\n} from \"./render-factory\"\n\n/**\n * Instruction centered on a merged node\n */\nexport class MergedNodeInstruction {\n    name: string\n\n    /**\n     * Create a new MergedNodeInstruction\n     * @param container Container that is the focal point of this instruction\n     * @param highlightDiff Highlight changed nodes\n     * @param section Section identifier\n     * @param header1 Header for this section\n     * @param header2 Header for this section\n     */\n    constructor(\n        readonly container: Container,\n        readonly highlightDiff: boolean,\n        readonly section: number,\n        readonly header1: string,\n        readonly header2: string,\n    ) {\n        this.name = container.name\n    }\n\n    /**\n     * Approximate the width of the longest input link name\n     */\n    get maxInputWidth(): number {\n        let maxInputWidth = 0\n        for (const producer of this.container.producers) {\n            for (const input of producer.inputs) {\n                maxInputWidth = Math.max(maxInputWidth, (FONTSIZE / 1.333) * input.name.length)\n            }\n        }\n        return maxInputWidth\n    }\n\n    /**\n     * Approximate the width of the longest output link name\n     */\n    get maxOutputWidth(): number {\n        let maxOutputWidth = 0\n        for (const consumer of this.container.consumers) {\n            maxOutputWidth = Math.max(maxOutputWidth, (FONTSIZE / 1.333) * consumer.name.length)\n        }\n        return maxOutputWidth\n    }\n\n    /**\n     * Approximate the width of this instruction SVG\n     */\n    get width(): number {\n        // -> industry -> container -> = 5x SIZE\n        // Add approximate width of longest input link and output link strings\n        let width = 5 * SIZE + this.maxInputWidth + this.maxOutputWidth\n        return width\n    }\n\n    /**\n     * Approximate the height of this instruction SVG\n     */\n    get height(): number {\n        // height is a little larger than 1.5*size of combined producers\n        let height = SIZE + 1.5 * SIZE * this.container.producers.size\n        return height\n    }\n\n    /**\n     * Generate SVG\n     */\n    render(): JSX.Element[] {\n        let elements: JSX.Element[] = []\n        let start_x = this.maxInputWidth\n        const start_y = 0.75 * SIZE\n\n        // Get producers and sort by name\n        const producers = Array.from(this.container.producers)\n        producers.sort((a, b) => sortName(a, b))\n\n        let element = null\n        let x = 0\n        let y = 0\n        let relayHeight = 1.5 * SIZE * this.container.producers.size\n\n        // Loop over producers\n        for (const [producer_i, producer] of producers.entries()) {\n            // Get input links and sort by name\n            const inputs = Array.from(producer.inputs)\n            inputs.sort((a, b) => sortName(a, b))\n\n            // Loop over input links\n            for (const [input_i, input] of inputs.entries()) {\n                x = start_x\n                y =\n                    start_y +\n                    1.5 * SIZE * producer_i +\n                    SIZE / 2 +\n                    LINKSPACING * (input_i - (inputs.length - 1) / 2)\n\n                // Add input link\n                element = (\n                    <text\n                        x={x}\n                        y={y}\n                        fill=\"black\"\n                        fontSize={FONTSIZE}\n                        dominantBaseline=\"middle\"\n                        textAnchor=\"end\"\n                        key={this.container.name + \"producer\" + producer_i + \"inputlink\" + input_i}\n                    >\n                        {input.name}\n                    </text>\n                )\n                elements.push(element)\n            }\n\n            x = start_x + SIZE\n            y = start_y + 1.5 * SIZE * producer_i\n\n            // add producer\n            element = (\n                <React.Fragment key={this.container.name + \"producer\" + producer_i}>\n                    <line\n                        x1={x - SIZE}\n                        y1={y + SIZE / 2}\n                        x2={x - 10}\n                        y2={y + SIZE / 2}\n                        stroke=\"#000\"\n                        strokeWidth=\"2\"\n                        markerEnd=\"url(#arrowhead)\"\n                    />\n                    {isTransferUnit(producer) && (\n                        <polygon\n                            points={`${x + SIZE / 2} ${y}, ${x + SIZE} ${y + SIZE / 2}, ${\n                                x + SIZE / 2\n                            } ${y + SIZE}, ${x} ${y + SIZE / 2}`}\n                            fill={this.highlightDiff && producer.changed ? \"magenta\" : \"gray\"}\n                            stroke=\"magenta\"\n                            strokeWidth=\"3\"\n                        />\n                    )}\n                    {isIndustry(producer) && (\n                        <circle\n                            cx={x + SIZE / 2}\n                            cy={y + SIZE / 2}\n                            r={SIZE / 2}\n                            fill={this.highlightDiff && producer.changed ? \"green\" : \"gray\"}\n                            stroke=\"green\"\n                            strokeWidth=\"3\"\n                        />\n                    )}\n                    <text\n                        x={x + SIZE / 2}\n                        y={y + SIZE / 2}\n                        fill=\"black\"\n                        fontSize={1.0 * FONTSIZE}\n                        dominantBaseline=\"middle\"\n                        textAnchor=\"middle\"\n                    >\n                        {isIndustry(producer) &&\n                            TIERLABELS[producer.item.tier] +\n                                INDUSTRYLABELS[producer.recipe.industry]}\n                        {isTransferUnit(producer) && producer.number + \"xTU\"}\n                    </text>\n                    <text\n                        x={x + SIZE / 2}\n                        y={y - 5}\n                        fill=\"black\"\n                        fontSize={FONTSIZE}\n                        dominantBaseline=\"auto\"\n                        textAnchor=\"middle\"\n                    >\n                        {producer.id}\n                    </text>\n                    <line\n                        x1={x + SIZE}\n                        y1={y + SIZE / 2}\n                        x2={x + SIZE + 5}\n                        y2={y + SIZE / 2}\n                        stroke=\"#000\"\n                        strokeWidth=\"2\"\n                    />\n                    <line\n                        x1={x + SIZE + 5}\n                        y1={y + SIZE / 2}\n                        x2={x + SIZE + 5}\n                        y2={start_y + relayHeight / 2 - SIZE / 4}\n                        stroke=\"#000\"\n                        strokeWidth=\"2\"\n                    />\n                </React.Fragment>\n            )\n            elements.push(element)\n        }\n\n        // add item name\n        element = (\n            <text\n                key={this.container.name + \"label\"}\n                x={start_x + 3 * SIZE}\n                y={0.5 * SIZE}\n                fill=\"black\"\n                fontSize={1.5 * FONTSIZE}\n                dominantBaseline=\"auto\"\n                textAnchor=\"middle\"\n                fontWeight=\"bold\"\n            >\n                {this.container.item.name}\n            </text>\n        )\n        elements.push(element)\n\n        // add container\n        x = start_x + 3 * SIZE\n        y = start_y + relayHeight / 2 - SIZE / 4\n        let ingress = this.container.ingress(this.container.item)\n        let egress = this.container.egress(this.container.item)\n        let steadyStateEgress = this.container.steadyStateEgress(this.container.item)\n        let outputRate = this.container.outputRate\n        let unit = \"sec\"\n        if (steadyStateEgress < 1) {\n            ingress *= 60.0\n            egress *= 60.0\n            steadyStateEgress *= 60.0\n            outputRate *= 60.0\n            unit = \"min\"\n        }\n        if (steadyStateEgress < 1) {\n            ingress *= 60.0\n            egress *= 60.0\n            steadyStateEgress *= 60.0\n            outputRate *= 60.0\n            unit = \"hour\"\n        }\n        if (steadyStateEgress < 1) {\n            ingress *= 24.0\n            egress *= 24.0\n            steadyStateEgress *= 24.0\n            outputRate *= 24.0\n            unit = \"day\"\n        }\n        ingress = Math.round(ingress * 100) / 100\n        egress = Math.round(egress * 100) / 100\n        steadyStateEgress = Math.round(steadyStateEgress * 100) / 100\n        outputRate = Math.round(outputRate * 100) / 100\n        element = (\n            <React.Fragment key={this.container.name}>\n                {this.container.producers.size > 0 && (\n                    <React.Fragment>\n                        <line\n                            x1={x - SIZE + 5}\n                            y1={y}\n                            x2={x - 10}\n                            y2={y}\n                            stroke=\"#000\"\n                            strokeWidth=\"2\"\n                            markerEnd=\"url(#arrowhead)\"\n                        />\n                        <text\n                            x={x - 2}\n                            y={y - 5}\n                            fill=\"green\"\n                            fontSize={FONTSIZE}\n                            dominantBaseline=\"auto\"\n                            textAnchor=\"end\"\n                        >\n                            {ingress + \"/\" + unit}\n                        </text>\n                    </React.Fragment>\n                )}\n                <line\n                    x1={x - SIZE / 2 + 10}\n                    y1={y}\n                    x2={x - 10}\n                    y2={y}\n                    stroke=\"#000\"\n                    strokeWidth=\"2\"\n                    markerEnd=\"url(#arrowhead)\"\n                />\n                <rect\n                    x={x}\n                    y={y - SIZE / 2}\n                    width={SIZE}\n                    height={SIZE}\n                    fill={this.highlightDiff && this.container.changed ? \"red\" : \"gray\"}\n                    stroke={outputRate > 0 ? \"blue\" : \"red\"}\n                    strokeWidth=\"3\"\n                />\n                <text\n                    x={x + SIZE / 2}\n                    y={y - SIZE / 2 - 5}\n                    fill=\"black\"\n                    fontSize={FONTSIZE}\n                    dominantBaseline=\"auto\"\n                    textAnchor=\"middle\"\n                >\n                    {this.container.id}\n                </text>\n                <text\n                    x={x + SIZE / 2}\n                    y={y + SIZE / 2 + 5}\n                    fill=\"black\"\n                    fontSize={FONTSIZE}\n                    dominantBaseline=\"hanging\"\n                    textAnchor=\"middle\"\n                >\n                    {Math.ceil(this.container.maintain)}\n                </text>\n                <text\n                    x={x + SIZE / 2}\n                    y={y}\n                    fill=\"black\"\n                    fontSize={1.0 * FONTSIZE}\n                    dominantBaseline=\"middle\"\n                    textAnchor=\"middle\"\n                >\n                    {containerLabel(this.container)}\n                </text>\n                {this.container.consumers.size > 0 && (\n                    <React.Fragment>\n                        <line\n                            x1={x + SIZE}\n                            y1={y}\n                            x2={x + 2 * SIZE - 10}\n                            y2={y}\n                            stroke=\"#000\"\n                            strokeWidth=\"2\"\n                            markerEnd=\"url(#arrowhead)\"\n                        />\n                        <text\n                            x={x + SIZE + 2}\n                            y={y - 5}\n                            fill=\"red\"\n                            fontSize=\"10\"\n                            dominantBaseline=\"auto\"\n                            textAnchor=\"start\"\n                        >\n                            {egress + \"/\" + unit}\n                        </text>\n                        <text\n                            x={x + SIZE + 2}\n                            y={y + 10}\n                            fill=\"blue\"\n                            fontSize=\"10\"\n                            dominantBaseline=\"auto\"\n                            textAnchor=\"start\"\n                        >\n                            {steadyStateEgress + \"/\" + unit}\n                        </text>\n                    </React.Fragment>\n                )}\n            </React.Fragment>\n        )\n        elements.push(element)\n\n        // Add byproduct consumers from this dump container\n        let numByproductConsumers = 0\n        for (const consumer of this.container.consumers) {\n            if (\n                isTransferUnit(consumer) &&\n                (isByproductTransferUnit(consumer) || isCatalystBalancer(consumer))\n            ) {\n                element = (\n                    <React.Fragment key={this.container.name + \"byproduct\" + consumer.name}>\n                        <text\n                            x={x + 1.5 * SIZE}\n                            y={y + SIZE / 2 + 30 + 1.1 * FONTSIZE * numByproductConsumers}\n                            fill=\"black\"\n                            fontSize=\"10\"\n                            dominantBaseline=\"auto\"\n                            textAnchor=\"end\"\n                        >\n                            {consumer.name}\n                        </text>\n                    </React.Fragment>\n                )\n                elements.push(element)\n\n                numByproductConsumers += 1\n            }\n        }\n        if (numByproductConsumers > 0) {\n            // Add arrow\n            element = (\n                <React.Fragment key={this.container.name + \"byproduct arrow\"}>\n                    <line\n                        x1={x + SIZE}\n                        y1={y + SIZE / 4}\n                        x2={x + 1.5 * SIZE - 10}\n                        y2={y + SIZE / 4}\n                        stroke=\"#000\"\n                        strokeWidth=\"2\"\n                        strokeDasharray=\"4\"\n                    />\n                    <line\n                        x1={x + 1.5 * SIZE - 10}\n                        y1={y + SIZE / 4}\n                        x2={x + 1.5 * SIZE - 10}\n                        y2={y + SIZE / 2 + 10}\n                        stroke=\"#000\"\n                        strokeWidth=\"2\"\n                        strokeDasharray=\"4\"\n                        markerEnd=\"url(#arrowhead)\"\n                    />\n                </React.Fragment>\n            )\n            elements.push(element)\n        }\n\n        // Get output links\n        const outputs = Array.from(this.container.consumers).filter(\n            (consumer) =>\n                !(\n                    isTransferUnit(consumer) &&\n                    (isByproductTransferUnit(consumer) || isCatalystBalancer(consumer))\n                ),\n        )\n        // Sort by name\n        outputs.sort((a, b) => sortName(a, b))\n\n        // Loop over output links\n        for (const [output_i, output] of outputs.entries()) {\n            x = start_x + 5 * SIZE\n            y =\n                start_y +\n                relayHeight / 2.0 -\n                SIZE / 4 +\n                LINKSPACING * (output_i - (outputs.length - 1) / 2)\n\n            // Add output link\n            const element = (\n                <text\n                    x={x}\n                    y={y}\n                    fill=\"black\"\n                    fontSize={FONTSIZE}\n                    dominantBaseline=\"middle\"\n                    textAnchor=\"start\"\n                    key={this.container.name + \"outputlink\" + output_i}\n                >\n                    {output.name}\n                </text>\n            )\n            elements.push(element)\n        }\n        return elements\n    }\n}\n","import * as React from \"react\"\nimport { FactoryNode } from \"../graph\"\nimport { sortName } from \"./generate-instructions\"\nimport { containerLabel, FONTSIZE, LINKSPACING, SIZE } from \"./render-factory\"\n\n/**\n * Instruction centered on a transfer container\n */\nexport class OreInstruction {\n    name: string\n\n    /**\n     * Create a new NodeInstruction\n     * @param node The factory node\n     * @param highlightDiff Highlight changed nodes\n     * @section Section identifier\n     * @header1 Header for this section\n     * @header2 Header for this section\n     */\n    constructor(\n        readonly node: FactoryNode,\n        readonly highlightDiff: boolean,\n        readonly section: number,\n        readonly header1: string,\n        readonly header2: string,\n    ) {\n        this.name = node.item.name\n    }\n\n    /**\n     * Approximate the width of the longest input link name\n     */\n    get maxInputWidth(): number {\n        // A little buffer\n        return 0.5 * SIZE\n    }\n\n    /**\n     * Approximate the width of the longest output link name\n     */\n    get maxOutputWidth(): number {\n        let maxOutputWidth = 0\n        for (const relayRoute of this.node.relayRoutes) {\n            for (const consumer of relayRoute.container.consumers) {\n                maxOutputWidth = Math.max(maxOutputWidth, (FONTSIZE / 1.333) * consumer.name.length)\n            }\n        }\n        return maxOutputWidth\n    }\n\n    /**\n     * Approximate the width of this instruction SVG\n     */\n    get width(): number {\n        // container -> <output name>\n        // = 2*SIZE + output lengths\n        let width = 2.0 * SIZE + this.maxInputWidth + this.maxOutputWidth\n        return width\n    }\n\n    /**\n     * Approximate the height of this instruction SVG\n     */\n    get height(): number {\n        return SIZE + 2.5 * SIZE * this.node.relayRoutes.length\n    }\n\n    /**\n     * Generate SVG\n     */\n    render(): JSX.Element[] {\n        let elements: JSX.Element[] = []\n        let start_x = 0.5 * SIZE\n        const start_y = 0.75 * SIZE\n        let relayStart_y = start_y\n\n        let x = 0\n        let y = 0\n        let element = null\n\n        // add item name\n        element = (\n            <text\n                key={this.node.relayRoutes[0].container.name + \"label\"}\n                x={start_x + SIZE}\n                y={0.5 * SIZE}\n                fill=\"black\"\n                fontSize={1.5 * FONTSIZE}\n                dominantBaseline=\"auto\"\n                textAnchor=\"middle\"\n                fontWeight=\"bold\"\n            >\n                {this.node.item.name}\n            </text>\n        )\n        elements.push(element)\n\n        for (const relayRoute of this.node.relayRoutes) {\n            // Add relay container\n            x = start_x\n            y = relayStart_y + SIZE / 2\n            let egress = relayRoute.container.egress(relayRoute.container.item)\n            let steadyStateEgress = relayRoute.container.steadyStateEgress(\n                relayRoute.container.item,\n            )\n            let outputRate = relayRoute.container.outputRate\n            let unit = \"sec\"\n            if (steadyStateEgress < 1) {\n                egress *= 60.0\n                steadyStateEgress *= 60.0\n                outputRate *= 60.0\n                unit = \"min\"\n            }\n            if (steadyStateEgress < 1) {\n                egress *= 60.0\n                steadyStateEgress *= 60.0\n                outputRate *= 60.0\n                unit = \"hour\"\n            }\n            if (steadyStateEgress < 1) {\n                egress *= 24.0\n                steadyStateEgress *= 24.0\n                outputRate *= 24.0\n                unit = \"day\"\n            }\n            egress = Math.round(egress * 100) / 100\n            steadyStateEgress = Math.round(steadyStateEgress * 100) / 100\n            outputRate = Math.round(outputRate * 100) / 100\n            element = (\n                <React.Fragment key={relayRoute.container.name}>\n                    <rect\n                        x={x}\n                        y={y}\n                        width={SIZE}\n                        height={SIZE}\n                        fill={this.highlightDiff && relayRoute.container.changed ? \"red\" : \"gray\"}\n                        stroke={outputRate > 0 ? \"blue\" : \"red\"}\n                        strokeWidth=\"3\"\n                    />\n                    <text\n                        x={x + SIZE / 2}\n                        y={y - 5}\n                        fill=\"black\"\n                        fontSize={FONTSIZE}\n                        dominantBaseline=\"auto\"\n                        textAnchor=\"middle\"\n                    >\n                        {relayRoute.container.id}\n                    </text>\n                    <text\n                        x={x + SIZE / 2}\n                        y={y + SIZE + 5}\n                        fill=\"black\"\n                        fontSize={FONTSIZE}\n                        dominantBaseline=\"hanging\"\n                        textAnchor=\"middle\"\n                    >\n                        {Math.ceil(relayRoute.container.maintain)}\n                    </text>\n                    <text\n                        x={x + SIZE / 2}\n                        y={y + SIZE / 2}\n                        fill=\"black\"\n                        fontSize={1.0 * FONTSIZE}\n                        dominantBaseline=\"middle\"\n                        textAnchor=\"middle\"\n                    >\n                        {containerLabel(relayRoute.container)}\n                    </text>\n                    {relayRoute.container.consumers.size > 0 && (\n                        <React.Fragment>\n                            <line\n                                x1={x + SIZE}\n                                y1={y + SIZE / 2}\n                                x2={x + 2 * SIZE - 10}\n                                y2={y + SIZE / 2}\n                                stroke=\"#000\"\n                                strokeWidth=\"2\"\n                                markerEnd=\"url(#arrowhead)\"\n                            />\n                            <text\n                                x={x + SIZE + 2}\n                                y={y + SIZE / 2 - 5}\n                                fill=\"red\"\n                                fontSize=\"10\"\n                                dominantBaseline=\"auto\"\n                                textAnchor=\"start\"\n                            >\n                                {egress + \"/\" + unit}\n                            </text>\n                            <text\n                                x={x + SIZE + 2}\n                                y={y + SIZE / 2 + 10}\n                                fill=\"blue\"\n                                fontSize=\"10\"\n                                dominantBaseline=\"auto\"\n                                textAnchor=\"start\"\n                            >\n                                {steadyStateEgress + \"/\" + unit}\n                            </text>\n                        </React.Fragment>\n                    )}\n                </React.Fragment>\n            )\n            elements.push(element)\n\n            // Add relay output links\n            const outputs = Array.from(relayRoute.container.consumers)\n            // Sort by name\n            outputs.sort((a, b) => sortName(a, b))\n\n            // Loop over output links\n            for (const [output_i, output] of outputs.entries()) {\n                x = start_x + 2 * SIZE\n                y = relayStart_y + SIZE + LINKSPACING * (output_i - (outputs.length - 1) / 2)\n\n                // Add output link\n                const element = (\n                    <text\n                        x={x}\n                        y={y}\n                        fill=\"black\"\n                        fontSize={FONTSIZE}\n                        dominantBaseline=\"middle\"\n                        textAnchor=\"start\"\n                        key={relayRoute.container.name + \"outputlink\" + output_i}\n                    >\n                        {output.name}\n                    </text>\n                )\n                elements.push(element)\n            }\n            relayStart_y += 2.5 * SIZE\n        }\n        return elements\n    }\n}\n","import { DumpRoute, FactoryGraph, isProductionNode } from \"../graph\"\nimport { Item } from \"../items\"\nimport { CATEGORY_ORDER, TIER_ORDER } from \"./render-factory\"\nimport { TransferContainerInstruction } from \"./transfer-container-instruction\"\nimport { NodeInstruction } from \"./node-instruction\"\nimport { MergedNodeInstruction } from \"./merge-node-instruction\"\nimport { OreInstruction } from \"./ore-instruction\"\nimport { FactoryElement } from \"../utils\"\n\nexport type FactoryInstruction =\n    | NodeInstruction\n    | MergedNodeInstruction\n    | TransferContainerInstruction\n    | OreInstruction\n\n/**\n * If an item name contains a terminal XS, S, M, L, or XL, replace\n * that with A, B, C, D, or E to support sorting\n * @param name the name to fix\n */\nfunction replaceSizeInName(name: string) {\n    name = name.replace(\" XS\", \" A\")\n    name = name.replace(\" S\", \" B\")\n    name = name.replace(\" M\", \" C\")\n    name = name.replace(\" L\", \" D\")\n    name = name.replace(\" XL\", \" E\")\n    return name\n}\n\n/**\n * Sorting function to sort factory elements or items by name, considering XS, S, M, L, XL\n * @param a First node\n * @param b Second node\n */\nexport function sortName(a: FactoryElement | Item, b: FactoryElement | Item): number {\n    let aName = replaceSizeInName(a.name)\n    let bName = replaceSizeInName(b.name)\n    return aName.localeCompare(bName, \"en\", { numeric: true })\n}\n\n/**\n * Generate the instruction set required to build a factory, in visualization order\n * @param factory the Factory graph\n * @param showDifferences if true, highlight changed nodes\n */\nexport function generateInstructions(\n    factory: FactoryGraph,\n    showDifferences: boolean,\n): FactoryInstruction[] {\n    const instructions: FactoryInstruction[] = []\n    let section = 0\n\n    // loop over category\n    for (const category of CATEGORY_ORDER) {\n        // Check if any transfer containers supply an industry in this category\n        const transferContainers = Array.from(factory.transferContainers).filter((node) =>\n            Array.from(node.consumers).some((consumer) => consumer.item.category === category),\n        )\n        // Sort by name\n        transferContainers.sort((a, b) => sortName(a, b))\n\n        // Add transferContainer instructions\n        for (const container of transferContainers) {\n            instructions.push(new TransferContainerInstruction(container, showDifferences, section))\n        }\n        section += 1\n\n        // loop over tier\n        for (const tier of TIER_ORDER) {\n            // Get nodes\n            const nodes = Array.from(factory.nodes.values()).filter(\n                (node) => node.item.category === category && node.item.tier === tier,\n            )\n            // Sort by name\n            nodes.sort((a, b) => sortName(a.item, b.item))\n\n            // Loop over nodes\n            for (const node of nodes) {\n                // Split nodes into instruction groups. A single instruction group will be\n                // one of the following:\n                // 0. No dumps, group all relays into a single instruction (e.g., ores)\n                // 1. One or more dumps feeding a single relay container or\n                // 2. One dump feeding one or more relay containers\n                const dumpGroups: DumpRoute[][] = []\n                if (isProductionNode(node)) {\n                    for (const dumpRoute of node.dumpRoutes) {\n                        // skip if this dump route is already grouped\n                        let skip = false\n                        for (const dumpGroup of dumpGroups) {\n                            if (dumpGroup.includes(dumpRoute)) {\n                                skip = true\n                            }\n                        }\n                        if (skip) {\n                            continue\n                        }\n\n                        // single dump feeds multiple relays\n                        if (dumpRoute.relayRoutes.length > 1) {\n                            dumpGroups.push([dumpRoute])\n                            continue\n                        }\n\n                        // Get all dump routes that feed this relay\n                        const dumpGroup = []\n                        for (const checkDumpRoute of node.dumpRoutes) {\n                            if (checkDumpRoute.relayRoutes.includes(dumpRoute.relayRoutes[0])) {\n                                dumpGroup.push(checkDumpRoute)\n                            }\n                        }\n                        dumpGroups.push(dumpGroup)\n                    }\n                } else {\n                    dumpGroups.push([])\n                }\n\n                // Loop over dump groups\n                for (const dumpGroup of dumpGroups) {\n                    if (dumpGroup.length === 0) {\n                        instructions.push(\n                            new OreInstruction(\n                                node,\n                                showDifferences,\n                                section,\n                                category,\n                                \"Tier \" + tier,\n                            ),\n                        )\n                    } else if (dumpGroup.length === 1 && dumpGroup[0].container.merged) {\n                        instructions.push(\n                            new MergedNodeInstruction(\n                                dumpGroup[0].relayRoutes[0].container,\n                                showDifferences,\n                                section,\n                                category,\n                                \"Tier \" + tier,\n                            ),\n                        )\n                    } else {\n                        instructions.push(\n                            new NodeInstruction(\n                                node,\n                                dumpGroup,\n                                showDifferences,\n                                section,\n                                category,\n                                \"Tier \" + tier,\n                            ),\n                        )\n                    }\n                }\n            }\n            section += 1\n        }\n    }\n    return instructions\n}\n","import * as React from \"react\"\nimport { Button, Row, Col, InputNumber, Divider } from \"antd\"\nimport { Item, Recipe } from \"../items\"\nimport { FactoryState } from \"./factory\"\nimport { buildFactory } from \"../generator\"\nimport { FactoryGraph, PerSecond } from \"../graph\"\nimport { FactoryInstruction, generateInstructions } from \"./generate-instructions\"\n\n/**\n * Properties of the FactoryCount component\n */\ninterface FactoryCountProps {\n    /**\n     * Set the parent NewFactory state\n     * @param state parent component state\n     */\n    setFactoryState: (state: FactoryState) => void\n\n    /**\n     * Set the error message\n     * @param error error message\n     */\n    setErrorMessage: (error: string) => void\n\n    // Items selected to build\n    selection: Item[]\n\n    // Recipes for selected items\n    recipes: Map<Item, Recipe>\n\n    /**\n     * Set the production rate and maintain value\n     */\n    setProductionRate: React.Dispatch<React.SetStateAction<{ [key: string]: number }>>\n    setMaintainValue: React.Dispatch<React.SetStateAction<{ [key: string]: number }>>\n\n    /**\n     * Get the production rate for a given item\n     * @param item Item to get assembler count\n     */\n    getProductionRate: (item: Item) => PerSecond\n\n    /**\n     * Get the maintain value for a given item\n     * @param item Item to get maintain value\n     */\n    getMaintainValue: (item: Item) => number\n\n    /**\n     * Get factory production requirements\n     */\n    getRequirements: () => Map<Item, { rate: PerSecond; maintain: number }>\n\n    // Talent levels\n    talentLevels: { [key: string]: number }\n\n    // the current FactoryGraph\n    factory: FactoryGraph | undefined\n\n    /**\n     * Set the factory graph\n     * @param factory the FactoryGraph\n     */\n    setFactory: (factory: FactoryGraph) => void\n\n    /**\n     * Set the factory instructions\n     * @param factoryInstructions the FactoryInstructions\n     */\n    setFactoryInstructions: (instructions: FactoryInstruction[]) => void\n\n    // flag to show differences from original factory\n    showDifferences: boolean\n}\n\n/**\n * Factory get number of assembers and maintain value\n * @param props {@link NewFactoryCountProps}\n */\nexport function FactoryCount(props: FactoryCountProps) {\n    return (\n        <React.Fragment>\n            <h2>Select Production Quantity and Maintain Values</h2>\n            <Divider orientation=\"left\">Instructions</Divider>\n            <ul>\n                <li>\n                    Produce Per Day: How many items to produce per day. Default value is the\n                    production rate for a single industry.\n                </li>\n                <li>Maintain: How many items to maintain in the factory output container</li>\n                <li>\n                    Required Industries: The required number of industries producing this item to\n                    fulfill the requested production rate\n                </li>\n            </ul>\n            <Divider orientation=\"left\">Set Production Quantity and Maintain Values</Divider>\n            <Row className=\"tableHeader\">\n                <Col span={3}>Item</Col>\n                <Col span={3}>Produce Per Day</Col>\n                <Col span={2}>Maintain</Col>\n                <Col span={4}>Required Industries</Col>\n            </Row>\n            {props.selection.map(function (item) {\n                const recipe = props.recipes.get(item)!\n                // Get the number of industries required to satisfy production rate\n                const numIndustries = Math.ceil(\n                    props.getProductionRate(item) / (recipe.quantity / recipe.time),\n                )\n                const setProductionRate = (value: number) => {\n                    props.setProductionRate((prevState: { [key: string]: number }) => ({\n                        ...prevState,\n                        [item.name]: value,\n                    }))\n                }\n                const setMaintainValue = (value: number) => {\n                    props.setMaintainValue((prevState: { [key: string]: number }) => ({\n                        ...prevState,\n                        [item.name]: value,\n                    }))\n                }\n                return (\n                    <React.Fragment key={item.name}>\n                        <MemorizedFactoryCountRow\n                            setProductionRate={setProductionRate}\n                            setMaintainValue={setMaintainValue}\n                            item={item}\n                            rate={props.getProductionRate(item) * (24.0 * 3600.0)}\n                            value={props.getMaintainValue(item)}\n                            numIndustries={numIndustries}\n                        />\n                    </React.Fragment>\n                )\n            })}\n            <Button\n                type=\"primary\"\n                onClick={() => {\n                    try {\n                        const newFactory = buildFactory(\n                            props.getRequirements(),\n                            props.talentLevels,\n                            props.factory,\n                        )\n                        props.setFactory(newFactory)\n                        props.setFactoryInstructions(\n                            generateInstructions(newFactory, props.showDifferences),\n                        )\n                        props.setFactoryState(FactoryState.RENDER)\n                    } catch (e) {\n                        props.setFactoryState(FactoryState.ERROR)\n                        props.setErrorMessage(e.message)\n                    }\n                }}\n            >\n                Next\n            </Button>\n        </React.Fragment>\n    )\n}\n\n/**\n * Properties of the FactoryCountRow\n */\ninterface FactoryCountRowProps {\n    setProductionRate: (rate: number) => void\n    setMaintainValue: (value: number) => void\n    item: Item\n    rate: number\n    value: number\n    numIndustries: number\n}\n\n/**\n * Single row of the factory count\n */\nfunction FactoryCountRow(props: FactoryCountRowProps) {\n    return (\n        <Row style={{ marginBottom: 2 }}>\n            <Col span={3}>\n                <label>{props.item.name}</label>\n            </Col>\n            <Col span={3}>\n                <InputNumber\n                    min={0}\n                    value={props.rate}\n                    onChange={(value) => props.setProductionRate(Number(value) / (24.0 * 3600.0))}\n                />\n            </Col>\n            <Col span={2}>\n                <InputNumber\n                    min={1}\n                    value={props.value}\n                    onChange={(value) => props.setMaintainValue(Number(value))}\n                />\n            </Col>\n            <Col span={4}>{props.numIndustries}</Col>\n        </Row>\n    )\n}\nfunction sameRow(oldProps: FactoryCountRowProps, newProps: FactoryCountRowProps) {\n    return oldProps.rate === newProps.rate && oldProps.value === newProps.value\n}\nconst MemorizedFactoryCountRow = React.memo(FactoryCountRow, sameRow)\n","import * as React from \"react\"\nimport { isCraftable, Item, ITEMS, Recipe, getRecipe } from \"../items\"\nimport { values } from \"ramda\"\nimport { AppState } from \"./app\"\nimport { Button, Upload, Row, Col, Divider } from \"antd\"\nimport { FactorySelect } from \"./factory-select\"\nimport { FactoryCount } from \"./factory-count\"\nimport { FactoryGraph, PerSecond } from \"../graph\"\nimport { FactoryVisualization } from \"./render-factory\"\nimport { deserialize } from \"../serialize\"\nimport { FactoryInstruction } from \"./generate-instructions\"\n\nexport enum FactoryState {\n    UPLOAD = \"upload\",\n    SELECT = \"select\",\n    COUNT = \"count\",\n    RENDER = \"render\",\n    ERROR = \"error\",\n}\n\n/**\n * Properties of the Factory component\n */\ninterface FactoryProps {\n    /**\n     * Set the parent application state\n     * @param state the AppState\n     */\n    setAppState: (state: AppState) => void\n\n    // User's talent levels\n    talentLevels: { [key: string]: number }\n\n    // Prices of ores\n    orePrices: { [key: string]: number }\n\n    // Starting factory state\n    startFactoryState: FactoryState\n}\n\n/**\n * Factory component\n * @param props {@link FactoryProps}\n */\nexport function Factory(props: FactoryProps) {\n    // all possible craftable items\n    const items = React.useMemo(() => values(ITEMS).filter(isCraftable), [ITEMS])\n    // current and previous factory state\n    const [factoryState, setFactoryState] = React.useState<FactoryState>(props.startFactoryState)\n    // error message\n    const [errorMessage, setErrorMessage] = React.useState<string>()\n    //  factory building instructions instructions\n    const [factoryInstructions, setFactoryInstructions] = React.useState<FactoryInstruction[]>([])\n    // produced items, industry count, and maintain count\n    const [selection, setSelection] = React.useState<Item[]>([])\n    const [productionRate, setProductionRate] = React.useState<{ [key: string]: PerSecond }>({})\n    const [maintainValue, setMaintainValue] = React.useState<{ [key: string]: number }>({})\n    // the recipes for all produced items\n    const recipes = React.useMemo(\n        () =>\n            new Map<Item, Recipe>(\n                selection.map((item) => [item, getRecipe(item, props.talentLevels)]),\n            ),\n        [selection],\n    )\n    // the FactoryGraph and a flag to show differences\n    const [showDifferences, setShowDifferences] = React.useState<boolean>(false)\n    const [startingFactory, setStartingFactory] = React.useState<FactoryGraph>()\n    const [factory, setFactory] = React.useState<FactoryGraph>()\n    // parse the production rate and maintain values, generate requirements\n    const getProductionRate = (item: Item) =>\n        productionRate[item.name] || recipes.get(item)!.quantity / recipes.get(item)!.time\n    const getMaintainValue = (item: Item) =>\n        maintainValue[item.name] || Math.ceil(getProductionRate(item) * 24 * 3600)\n    const getRequirements = () =>\n        new Map<Item, { rate: PerSecond; maintain: number }>(\n            selection.map((item) => [\n                item,\n                { rate: getProductionRate(item), maintain: getMaintainValue(item) },\n            ]),\n        )\n\n    switch (factoryState) {\n        default:\n            return (\n                <React.Fragment>\n                    <Button onClick={() => props.setAppState(AppState.HOME)}>Back</Button>\n                    <ExistingFactorySummary factory={startingFactory} />\n                    <FactorySelect\n                        setFactoryState={setFactoryState}\n                        items={items}\n                        selection={selection}\n                        setSelection={setSelection}\n                        setProductionRate={setProductionRate}\n                        setMaintainValue={setMaintainValue}\n                    />\n                </React.Fragment>\n            )\n        case FactoryState.UPLOAD:\n            return (\n                <React.Fragment>\n                    <Button onClick={() => props.setAppState(AppState.HOME)}>Back</Button>\n                    <h2>Start from an Existing Factory</h2>\n                    <Divider orientation=\"left\">Instructions</Divider>\n                    <ul>\n                        <li>Upload a JSON file previously generated by this tool.</li>\n                    </ul>\n                    <Divider orientation=\"left\">Upload</Divider>\n                    <Upload\n                        accept=\".json\"\n                        showUploadList={false}\n                        beforeUpload={(file) => {\n                            const reader = new FileReader()\n                            reader.onload = () => {\n                                const factoryJSON = reader.result as string\n                                let uploadedFactory: FactoryGraph | undefined = undefined\n                                try {\n                                    uploadedFactory = deserialize(factoryJSON, props.talentLevels)\n                                } catch (e) {\n                                    setFactoryState(FactoryState.ERROR)\n                                    setErrorMessage(e.message)\n                                    return\n                                }\n                                setStartingFactory(uploadedFactory)\n                                // create another copy to be modified\n                                const uploadedFactoryCopy = deserialize(\n                                    factoryJSON,\n                                    props.talentLevels,\n                                )\n                                setFactory(uploadedFactoryCopy)\n                                setShowDifferences(true)\n                                setStartingFactory(uploadedFactory)\n                                setFactoryState(FactoryState.SELECT)\n                            }\n                            reader.readAsText(file)\n                            // skip upload\n                            return false\n                        }}\n                    >\n                        <Button type=\"primary\">Upload Factory JSON</Button>\n                    </Upload>\n                </React.Fragment>\n            )\n        case FactoryState.COUNT:\n            return (\n                <React.Fragment>\n                    <Button onClick={() => setFactoryState(FactoryState.SELECT)}>Back</Button>\n                    <ExistingFactorySummary factory={startingFactory} />\n                    <FactoryCount\n                        selection={selection}\n                        recipes={recipes}\n                        setFactoryState={setFactoryState}\n                        setErrorMessage={setErrorMessage}\n                        setProductionRate={setProductionRate}\n                        getProductionRate={getProductionRate}\n                        setMaintainValue={setMaintainValue}\n                        getMaintainValue={getMaintainValue}\n                        getRequirements={getRequirements}\n                        talentLevels={props.talentLevels}\n                        factory={factory}\n                        setFactory={setFactory}\n                        setFactoryInstructions={setFactoryInstructions}\n                        showDifferences={showDifferences}\n                    />\n                </React.Fragment>\n            )\n        case FactoryState.RENDER:\n            return (\n                <FactoryVisualization\n                    factory={factory}\n                    setFactory={setFactory}\n                    startingFactory={startingFactory}\n                    setFactoryState={setFactoryState}\n                    instructions={factoryInstructions!}\n                    selection={selection}\n                    orePrices={props.orePrices}\n                />\n            )\n        case FactoryState.ERROR:\n            return (\n                <React.Fragment>\n                    <Button onClick={() => props.setAppState(AppState.HOME)}>Back</Button>\n                    <h2>\n                        <div id=\"error\">Factory Error</div>\n                    </h2>\n                    {errorMessage} <br />\n                    <div id=\"error\">\n                        If this error is unexpected, then please report this to the developers via\n                        Discord or the \"Report an Issue\" link below! Please include all necessary\n                        information that can be used to reproduce this error (e.g., what you were\n                        trying to produce, factory JSON file if you started from a previous factory,\n                        etc.).\n                    </div>\n                </React.Fragment>\n            )\n    }\n}\n\n/**\n * Properties of the ExistingFactorySummary component\n */\ninterface ExistingFactorySummaryProps {\n    // the factory graph\n    factory: FactoryGraph | undefined\n}\n\n/**\n * ExistingFactoryFactory component\n * @param props {@link ExistingFactorySummaryProps}\n */\nexport function ExistingFactorySummary({ factory }: ExistingFactorySummaryProps) {\n    if (factory === undefined) {\n        return <React.Fragment></React.Fragment>\n    }\n\n    const elements = []\n    for (const output of factory.containers) {\n        if (output.outputRate > 0) {\n            let productionRate = output.outputRate\n            let unit = \"second\"\n            if (productionRate < 1.0) {\n                productionRate *= 60.0\n                unit = \"minute\"\n            }\n            if (productionRate < 1.0) {\n                productionRate *= 60.0\n                unit = \"hour\"\n            }\n            if (productionRate < 1.0) {\n                productionRate *= 24.0\n                unit = \"day\"\n            }\n            // round to 2 decimals\n            productionRate = Math.round(productionRate * 100) / 100\n            const element = (\n                <Row key={output.name}>\n                    <Col span={3}>{output.item.name}</Col>\n                    <Col span={3}>{productionRate + \" / \" + unit}</Col>\n                    <Col span={3}>{Math.round(output.maintainedOutput)}</Col>\n                </Row>\n            )\n            elements.push(element)\n        }\n    }\n\n    if (elements.length > 0) {\n        return (\n            <React.Fragment>\n                <h2>Existing Factory Production</h2>\n                <Row className=\"tableHeader\">\n                    <Col span={3}>Item</Col>\n                    <Col span={3}>Production Rate</Col>\n                    <Col span={3}>Maintain</Col>\n                </Row>\n                {elements}\n            </React.Fragment>\n        )\n    }\n    return <React.Fragment></React.Fragment>\n}\n","import * as React from \"react\"\nimport { Button, Row, Col, Upload, Space, Divider } from \"antd\"\nimport { PlusOutlined, MinusOutlined } from \"@ant-design/icons\"\nimport { Talent, TALENTS, TalentGroup } from \"../talents\"\nimport { AppState, TalentState } from \"./app\"\n\nconst TALENT_GROUPS: { [key: string]: Set<string> } = {}\nObject.values(TalentGroup).map((group) => {\n    TALENT_GROUPS[group] = new Set()\n    Object.values(TALENTS)\n        .filter((talent) => talent.talentGroup == group)\n        .map((talent) => {\n            TALENT_GROUPS[group].add(talent.skillGroup)\n        })\n})\n\n/**\n * Parse JSON and set talent levels\n */\nexport function parseTalentLevelJSON(\n    json: string,\n    setTalentLevels: React.Dispatch<React.SetStateAction<{ [key: string]: number }>>,\n) {\n    const data = JSON.parse(json) as { [key: string]: number }\n    for (const [talent, level] of Object.entries(data)) {\n        setTalentLevels((prevState: { [key: string]: number }) => ({\n            ...prevState,\n            [talent]: level,\n        }))\n    }\n}\n\n/**\n * Single row of the talent table\n */\ninterface SetTalentRowProps {\n    setTalentLevels: (value: number) => void\n    talent: Talent\n    value: number\n}\nfunction SetTalentsRow(props: SetTalentRowProps) {\n    const label = props.talent.name.split(\": \")[1]\n    return (\n        <div className=\"setTalent\">\n            <Row>\n                <Col span={12}>\n                    <label>{label}</label>\n                </Col>\n                <Col span={12}>\n                    {[...Array(6)].map((_, i) => {\n                        let type = \"default\"\n                        if (i === props.value) {\n                            type = \"primary\"\n                        } else if (i > props.value) {\n                            type = \"dashed\"\n                        }\n                        return (\n                            <Button\n                                key={props.talent.name + i}\n                                type={\n                                    props.value === i\n                                        ? \"primary\"\n                                        : props.value < i\n                                        ? \"dashed\"\n                                        : \"default\"\n                                }\n                                onClick={() => props.setTalentLevels(i)}\n                            >\n                                {i}\n                            </Button>\n                        )\n                    })}\n                </Col>\n            </Row>\n        </div>\n    )\n}\nfunction sameRow(oldProps: SetTalentRowProps, newProps: SetTalentRowProps) {\n    return oldProps.value === newProps.value\n}\nconst MemorizedSetTalentsRow = React.memo(SetTalentsRow, sameRow)\n\n/**\n * Single skill group of the talent table\n */\ninterface SkillGroupProps {\n    skillGroup: string\n    setTalentLevels: React.Dispatch<React.SetStateAction<{ [key: string]: number }>>\n    children?: JSX.Element | JSX.Element[]\n}\nfunction SkillGroup(props: SkillGroupProps) {\n    const [selected, setSelected] = React.useState<boolean>(false)\n    return (\n        <React.Fragment>\n            <div className=\"skillGroup\" onClick={() => setSelected(!selected)}>\n                {selected ? <MinusOutlined /> : <PlusOutlined />}\n                {props.skillGroup}\n            </div>\n            {selected ? props.children : \"\"}\n        </React.Fragment>\n    )\n}\n\n/**\n * Single talent group of the talent table\n */\ninterface TalentGroupCompProps {\n    talentGroup: string\n    setTalentLevels: React.Dispatch<React.SetStateAction<{ [key: string]: number }>>\n    children?: JSX.Element | JSX.Element[]\n}\nfunction TalentGroupComp(props: TalentGroupCompProps) {\n    const [selected, setSelected] = React.useState<boolean>(false)\n    return (\n        <React.Fragment>\n            <div className=\"talentGroup\" onClick={() => setSelected(!selected)}>\n                {selected ? <MinusOutlined /> : <PlusOutlined />}\n                {props.talentGroup}\n            </div>\n            {selected ? props.children : \"\"}\n        </React.Fragment>\n    )\n}\n\n/**\n * Properties of the SetTalents component\n */\ninterface SetTalentsProps {\n    /**\n     * Set the parent NewFactory state\n     * @param state parent component state\n     */\n    setAppState: (state: AppState) => void\n\n    // factory talents and levels\n    talentLevels: { [key: string]: number }\n\n    /**\n     * Set the level for a given talent\n     */\n    setTalentLevels: React.Dispatch<React.SetStateAction<{ [key: string]: number }>>\n\n    /**\n     * Set the TalentState\n     */\n    setTalentState: (state: TalentState) => void\n}\n\n/**\n * Set talent levels\n * @param props {@link SetTalentsProps}\n */\nexport function SetTalents(props: SetTalentsProps) {\n    const [uploaded, setUploaded] = React.useState<boolean>(false)\n\n    return (\n        <React.Fragment>\n            <h2>Set Talents</h2>\n            <Divider orientation=\"left\">Instructions</Divider>\n            <ul>\n                <li>Set talents of user who is placing and running industries.</li>\n                <li>Talents are stored as a cookie in your browser.</li>\n                <li>At the bottom of this page, you can download your talents as a JSON file.</li>\n                <li>You may upload a JSON file that was previously exported from this page.</li>\n            </ul>\n            <Divider orientation=\"left\">Upload</Divider>\n            <Space>\n                <Upload\n                    accept=\".json\"\n                    showUploadList={false}\n                    beforeUpload={(file) => {\n                        const reader = new FileReader()\n                        reader.onload = () => {\n                            const result = reader.result as string\n                            parseTalentLevelJSON(result, props.setTalentLevels)\n                            setUploaded(true)\n                        }\n                        reader.readAsText(file)\n                        // skip upload\n                        return false\n                    }}\n                >\n                    <Button>Upload Talent JSON</Button>\n                </Upload>\n                {uploaded && \"Upload successful!\"}\n            </Space>\n            <Divider orientation=\"left\">Update Talents</Divider>\n            {Object.keys(TALENT_GROUPS).map(function (talentGroup) {\n                return (\n                    <TalentGroupComp\n                        key={\"talentGroup: \" + talentGroup}\n                        talentGroup={talentGroup}\n                        setTalentLevels={props.setTalentLevels}\n                    >\n                        {Array.from(TALENT_GROUPS[talentGroup]).map(function (skillGroup) {\n                            return (\n                                <SkillGroup\n                                    key={\"skillGroup: \" + skillGroup}\n                                    skillGroup={skillGroup}\n                                    setTalentLevels={props.setTalentLevels}\n                                >\n                                    {Object.values(TALENTS)\n                                        .filter((talent) => talent.skillGroup === skillGroup)\n                                        .map(function (talent) {\n                                            const setTalentLevels = (value: number) => {\n                                                props.setTalentLevels(\n                                                    (prevState: { [key: string]: number }) => ({\n                                                        ...prevState,\n                                                        [talent.name]: value,\n                                                    }),\n                                                )\n                                            }\n                                            return (\n                                                <MemorizedSetTalentsRow\n                                                    key={\"talent: \" + talent.name}\n                                                    setTalentLevels={setTalentLevels}\n                                                    talent={talent}\n                                                    value={props.talentLevels[talent.name] || 0}\n                                                />\n                                            )\n                                        })}\n                                </SkillGroup>\n                            )\n                        })}\n                    </TalentGroupComp>\n                )\n            })}\n            <br />\n            <Space>\n                <Button\n                    type=\"primary\"\n                    onClick={() => {\n                        // save to localStorage\n                        localStorage.setItem(\"talentLevels\", JSON.stringify(props.talentLevels))\n                        props.setTalentState(TalentState.SET)\n                        props.setAppState(AppState.HOME)\n                    }}\n                >\n                    Confirm\n                </Button>\n                <Button\n                    href={`data:text/json;charset=utf-8,${encodeURIComponent(\n                        JSON.stringify(props.talentLevels),\n                    )}`}\n                    download=\"talents.json\"\n                >\n                    Download Talents as JSON\n                </Button>\n            </Space>\n        </React.Fragment>\n    )\n}\n\nfunction expandTalentGroup(talentGroup: string) {}\n","import * as React from \"react\"\nimport { Button, Row, Col, InputNumber, Upload, Divider, Space } from \"antd\"\nimport { ITEMS, isOre } from \"../items\"\nimport { AppState, OrePricesState } from \"./app\"\n\n/**\n * Parse JSON and set ore prices\n */\nexport function parseOrePricesJSON(\n    json: string,\n    setOrePrices: React.Dispatch<React.SetStateAction<{ [key: string]: number }>>,\n) {\n    const data = JSON.parse(json) as { [key: string]: number }\n    for (const [item, price] of Object.entries(data)) {\n        setOrePrices((prevState: { [key: string]: number }) => ({\n            ...prevState,\n            [item]: price,\n        }))\n    }\n}\n\n/**\n * Properties of the SetOrePrices component\n */\ninterface SetOrePricesProps {\n    /**\n     * Set the parent NewFactory state\n     * @param state parent component state\n     */\n    setAppState: (state: AppState) => void\n\n    // ore prices\n    orePrices: { [key: string]: number }\n\n    /**\n     * Set the price for a given ore\n     */\n    setOrePrices: React.Dispatch<React.SetStateAction<{ [key: string]: number }>>\n\n    /**\n     * Set the OrePricesState\n     */\n    setOrePricesState: (state: OrePricesState) => void\n}\n\n/**\n * Set ore prices\n * @param props {@link SetOrePricesProps}\n */\nexport function SetOrePrices(props: SetOrePricesProps) {\n    const [uploaded, setUploaded] = React.useState<boolean>(false)\n\n    return (\n        <React.Fragment>\n            <h2>Set Ore Prices</h2>\n            <Divider orientation=\"left\">Instructions</Divider>\n            <ul>\n                <li>Ore prices are stored as a cookie in your browser.</li>\n                <li>At the bottom of this page, you can download the ore prices as a JSON file.</li>\n                <li>You may upload a JSON file that was previously exported from this page.</li>\n            </ul>\n            <Divider orientation=\"left\">Upload</Divider>\n            <Space>\n                <Upload\n                    accept=\".json\"\n                    showUploadList={false}\n                    beforeUpload={(file) => {\n                        const reader = new FileReader()\n                        reader.onload = () => {\n                            const result = reader.result as string\n                            parseOrePricesJSON(result, props.setOrePrices)\n                            setUploaded(true)\n                        }\n                        reader.readAsText(file)\n                        // skip upload\n                        return false\n                    }}\n                >\n                    <Button>Upload Ore Prices JSON</Button>\n                </Upload>\n                {uploaded && \"Upload successful!\"}\n            </Space>\n            <Divider orientation=\"left\">Update Ore Prices</Divider>\n            {Object.values(ITEMS)\n                .filter(isOre)\n                .map(function (item) {\n                    // handle update of ore price\n                    const setOrePrices = (value: number) => {\n                        props.setOrePrices((prevState: { [key: string]: number }) => ({\n                            ...prevState,\n                            [item.name]: value,\n                        }))\n                    }\n                    return (\n                        <React.Fragment key={item.name}>\n                            <MemorizedSetOrePricesRow\n                                setOrePrices={setOrePrices}\n                                item={item.name}\n                                value={props.orePrices[item.name] || 0}\n                            />\n                        </React.Fragment>\n                    )\n                })}\n            <br />\n            <Space>\n                <Button\n                    type=\"primary\"\n                    onClick={() => {\n                        // save to localStorage\n                        localStorage.setItem(\"orePrices\", JSON.stringify(props.orePrices))\n                        props.setOrePricesState(OrePricesState.SET)\n                        props.setAppState(AppState.HOME)\n                    }}\n                >\n                    Confirm\n                </Button>\n                <Button\n                    href={`data:text/json;charset=utf-8,${encodeURIComponent(\n                        JSON.stringify(props.orePrices),\n                    )}`}\n                    download=\"orePrices.json\"\n                >\n                    Download Ore Prices as JSON\n                </Button>\n            </Space>\n        </React.Fragment>\n    )\n}\n\n/**\n * Properties of the SetOrePricesRow\n */\ninterface SetOrePricesRowProps {\n    setOrePrices: (value: number) => void\n    item: string\n    value: number\n}\n\n/**\n * Single row of the ore prices table\n */\nfunction SetOrePricesRow(props: SetOrePricesRowProps) {\n    return (\n        <Row>\n            <Col span={2}>\n                <label>{props.item}</label>\n            </Col>\n            <Col span={2}>\n                <InputNumber\n                    min={0}\n                    value={props.value}\n                    onChange={(value: string | number | undefined) =>\n                        props.setOrePrices(Number(value))\n                    }\n                />\n            </Col>\n        </Row>\n    )\n}\nfunction sameRow(oldProps: SetOrePricesRowProps, newProps: SetOrePricesRowProps) {\n    return oldProps.value === newProps.value\n}\nconst MemorizedSetOrePricesRow = React.memo(SetOrePricesRow, sameRow)\n","import * as React from \"react\"\nimport { Button, Space, Row, Col, Divider } from \"antd\"\nimport { Info } from \"./info\"\nimport { Factory, FactoryState } from \"./factory\"\nimport { SetTalents, parseTalentLevelJSON } from \"./set-talents\"\nimport { SetOrePrices, parseOrePricesJSON } from \"./set-ore-prices\"\n\nexport enum AppState {\n    HOME = \"home\",\n    INFO = \"info\",\n    SETTALENTS = \"setTalents\",\n    SETOREPRICES = \"setOrePrices\",\n    NEWFACTORY = \"newFactory\",\n    OLDFACTORY = \"oldFactory\",\n}\n\nexport enum TalentState {\n    UNSET = \"unset\",\n    SET = \"set\",\n}\n\nexport enum OrePricesState {\n    UNSET = \"unset\",\n    SET = \"set\",\n}\n\n/**\n * Main application component\n */\nexport function App() {\n    const [appState, setAppState] = React.useState<AppState>(AppState.HOME)\n    const [talentState, setTalentState] = React.useState<TalentState>(TalentState.UNSET)\n    const [talentLevels, setTalentLevels] = React.useState<{ [key: string]: number }>({})\n    const [orePricesState, setOrePricesState] = React.useState<OrePricesState>(OrePricesState.UNSET)\n    const [orePrices, setOrePrices] = React.useState<{ [key: string]: number }>({})\n\n    // Parse talentLevel cookie JSON if present\n    if (talentState === TalentState.UNSET) {\n        const data = localStorage.getItem(\"talentLevels\")\n        if (data !== null) {\n            parseTalentLevelJSON(data, setTalentLevels)\n            setTalentState(TalentState.SET)\n        }\n    }\n\n    // Parse orePrices cookie JSON if present\n    if (orePricesState === OrePricesState.UNSET) {\n        const data = localStorage.getItem(\"orePrices\")\n        if (data !== null) {\n            parseOrePricesJSON(data, setOrePrices)\n            setOrePricesState(OrePricesState.SET)\n        }\n    }\n\n    let content = null\n    switch (appState) {\n        default:\n            content = (\n                <React.Fragment>\n                    <h2>Welcome to the DU Factory Generator!</h2>\n                    This is a factory generator for&nbsp;\n                    <a href=\"https://www.dualuniverse.game/\">Dual Universe</a>. Given a set of items\n                    to build, this tool will determine a factory plan from raw ores to the final\n                    products. The factory is designed to support the production rates of all\n                    intermediate industries. Therefore, this is a factory plan that will maximize\n                    production efficiency even after production interruptions. If you encouter any\n                    problems or would like to request new features, please submit an{\" \"}\n                    <a href=\"https://github.com/tvwenger/du-factory-generator/issues\">\n                        issue on Github\n                    </a>\n                    , or <a href=\"https://discord.gg/gXSWKqVnHx\">join our Discord server</a>.\n                    <Divider orientation=\"left\">Instructions</Divider>\n                    <ul>\n                        <li>Set or update talents as necessary.</li>\n                        <li>\n                            Optional: set ore prices to calculate \"ore values\" of produced items.\n                        </li>\n                        <li>Start a New Factory: Set up a new factory from scratch.</li>\n                        <li>\n                            Start From Existing Factory: Start from a factory previously generated\n                            by this tool.\n                        </li>\n                    </ul>\n                    <Divider orientation=\"left\">Preparation</Divider>\n                    <Row style={{ marginBottom: 5 }}>\n                        <Col span={3}>\n                            <Button onClick={() => setAppState(AppState.SETTALENTS)}>\n                                {talentState === TalentState.SET ? \"Update Talents\" : \"Set Talents\"}\n                            </Button>\n                        </Col>\n                        <Col span={3}>\n                            {talentState === TalentState.SET\n                                ? \"Talents are set\"\n                                : \"Talents have not been set\"}\n                        </Col>\n                    </Row>\n                    <Row>\n                        <Col span={3}>\n                            <Button onClick={() => setAppState(AppState.SETOREPRICES)}>\n                                {orePricesState === OrePricesState.SET\n                                    ? \"Update Ore Prices\"\n                                    : \"Set Ore Prices\"}\n                            </Button>\n                        </Col>\n                        <Col span={3}>\n                            {orePricesState === OrePricesState.SET\n                                ? \"Ore prices are set\"\n                                : \"Ore prices have not been set\"}\n                        </Col>\n                    </Row>\n                    <Divider orientation=\"left\">Generate Factory</Divider>\n                    <Space>\n                        <Button type=\"primary\" onClick={() => setAppState(AppState.NEWFACTORY)}>\n                            Start a New Factory\n                        </Button>\n                        <Button onClick={() => setAppState(AppState.OLDFACTORY)}>\n                            Start from Existing Factory\n                        </Button>\n                        <Button onClick={() => setAppState(AppState.INFO)}>Help Information</Button>\n                    </Space>\n                </React.Fragment>\n            )\n            break\n        case AppState.INFO:\n            content = <Info setAppState={setAppState} />\n            break\n        case AppState.SETTALENTS:\n            content = (\n                <SetTalents\n                    setAppState={setAppState}\n                    talentLevels={talentLevels}\n                    setTalentLevels={setTalentLevels}\n                    setTalentState={setTalentState}\n                />\n            )\n            break\n        case AppState.SETOREPRICES:\n            content = (\n                <SetOrePrices\n                    setAppState={setAppState}\n                    orePrices={orePrices}\n                    setOrePrices={setOrePrices}\n                    setOrePricesState={setOrePricesState}\n                />\n            )\n            break\n        case AppState.NEWFACTORY:\n            content = (\n                <Factory\n                    setAppState={setAppState}\n                    talentLevels={talentLevels}\n                    orePrices={orePrices}\n                    startFactoryState={FactoryState.SELECT}\n                />\n            )\n            break\n        case AppState.OLDFACTORY:\n            content = (\n                <Factory\n                    setAppState={setAppState}\n                    talentLevels={talentLevels}\n                    orePrices={orePrices}\n                    startFactoryState={FactoryState.UPLOAD}\n                />\n            )\n            break\n    }\n\n    return content\n}\n","import * as React from \"react\"\nimport * as ReactDOM from \"react-dom\"\nimport \"antd/dist/antd.css\"\nimport { App } from \"./ui/app\"\n\nconst rootElement = document.getElementById(\"root\")\nReactDOM.render(<App />, rootElement)\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/du-factory-generator/v4.1/\";","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t179: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkIds[i]] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunk\"] = self[\"webpackChunk\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [736], () => (__webpack_require__(3074)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","example","Info","setAppState","onClick","AppState","HOME","href","src","default","width","TalentType","TalentSubject","TalentGroup","talent","name","skillGroup","talentGroup","type","subject","modifier","target","targetCategory","targetTier","talents","data","outer","inner","skill","skills","undefined","class","amount","tier","Object","entries","values","includes","Error","TALENTS","Tier","Category","isOre","item","category","ORE","isGas","GAS","isCraftable","isCatalyst","CATALYST","volume","transferBatchSize","transferTime","recipe","quantity","time","industry","byproducts","ingredients","items","recipes","SCRAP","FUEL","PURE_HONEYCOMB","PRODUCT_HONEYCOMB","PRODUCT","PURE","COMPLEX_PART","INTERMEDIARY_PART","Map","byproduct","set","ingredient","input","outputQuantity","ITEMS","RECIPES","getRecipe","talentLevels","oldRecipe","time_mod","input_mod","output_mod","level","applicable","INDUSTRY","ITEM","TYPE","TIER","TIME","INPUT","OUTPUT","key","value","containerCapacity","capacity","CONTAINERS_ASCENDING_BY_CAPACITY","CATALYSTS","filter","getRequiredOres","requiredOres","ores","batchSize","ingredientQuantity","ingredientOres","ore","oreQuantity","ItemSelect","props","treeData","useMemo","byCategory","groupBy","prop","toPairs","map","title","children","useItemTreeData","fromValue","selection","byName","indexBy","itemNames","itemName","useItemSelection","style","dropdownStyle","maxHeight","overflow","placeholder","multiple","allowClear","showArrow","treeCheckable","onChange","compose","FactorySelect","orientation","accept","showUploadList","beforeUpload","file","reader","FileReader","onload","lines","result","split","myItems","line","parts","trim","find","element","push","setProductionRate","prevState","Number","setMaintainValue","console","log","setSelection","setFactoryState","FactoryState","COUNT","readAsText","length","shortenName","replace","TransferUnit","constructor","id","output","inputs","Set","requiredTransferRate","transferRates","changed","merged","this","addProducer","removeInput","node","delete","removeConsumer","addInput","add","addConsumer","has","setOutput","incomingLinkCount","size","canAddIncomingLink","MAX_INDUSTRY_LINKS","increaseRequiredTransferRate","rate","decreaseRequiredTransferRate","setTransferRate","container","increaseTransferRate","get","inflowRateFrom","steadyStateInflowRateFrom","totalInflow","Array","from","reduce","total","current","fraction","steadyStateEgress","outflowRateTo","number","transferRatePer","Math","ceil","isTransferUnit","isByproductTransferUnit","some","keys","isCatalystBalancer","consumers","consumer","isContainer","TransferContainer","producers","outgoingLinkCount","MAX_CONTAINER_LINKS","canAddOutgoingLink","ingress","totalIngress","ingressFrom","egress","totalEgress","egressTo","maintain","isTransferContainer","containers","remainingCapacity","requiredContainers","foundContainer","Industry","isSuppliedWith","inflowRateOf","steadyStateInflowRateOf","outputEgress","numProducers","isIndustry","Container","outputRate","maintainedOutput","producer","incomingLinksFree","numReserved","outgoingLinksFree","isDumpContainer","canAddIncomingLinks","num","canAddOutgoingLinks","setOutputRate","setMaintainedOutput","removeProducer","generateDumpRoutes","singleGas","delta","relayRoute","getRelayRoutes","relayEgress","found","dumpRoute","dumpRoutes","transferUnit","relayRoutes","dumpContainer","factory","createDumpContainer","industries","createIndustry","currentSurplus","newIngress","newEgress","min","newIndustries","i","checkRelayRoute","checkDumpRoute","lastEgress","abs","FactoryNode","isRelayRouted","outputRelays","route","outputRelaysRate","relay","outputRelaysMaintain","maxTransferNumber","maxTransferRate","getIndustriesNeeding","addIndustries","lastLength","createRelayContainer","createTransferUnit","rateDiff","maintainDiff","increaseRate","increaseMaintain","lastRateDiff","generateRelayRoutes","OreNode","super","isOreNode","ProductionNode","isDumpRouted","getDumpRoutes","isProductionNode","FactoryGraph","nodes","transferUnits","transferContainers","getNode","oreNodes","gasNodes","dumpContainers","getDumpContainers","getRelayContainers","getTransferUnits","getByproductTransferUnits","getIndustries","getTransferContainers","createOreNode","createProductionNode","createTransferContainer","addProductionNode","productionNode","buildFactory","requirements","relayContainer","unmergeFactory","tuContainer","share","foundTransferUnit","outputContainer","minTransferUnits","checkContainer","numTransferUnits","handleByproducts","catalyst","lastContainer","balanceCatalysts","exceedingLinkCount","sort","a","b","transferContainer","checkTransferContainer","transferUnitsGood","slice","check","transferRate","handleTransferContainers","handleGas","relayContainerChanged","producerChanged","consumerChanged","containerChanged","mergeFactory","sanityCheck","VERSION","serialize","factoryNodes","factoryContainers","factoryIndustries","factoryTransferUnits","factoryTransferContainers","saveFactory","version","saveContainer","producerIndustries","indexOf","producerTransferUnits","consumerIndustries","consumerTransferUnits","saveIndustry","inputContainers","inputTransferContainers","saveTransferUnit","rates","outputTransferContainer","saveTransferContainer","saveRelayContainers","saveRelayTransferUnits","saveDumpRelays","saveDumpContainers","saveDumpIndustries","saveFactoryNode","relayRouteContainers","relayRouteTransferUnits","dumpRouteRelays","dumpRouteContainers","dumpRouteIndustries","JSON","stringify","deserialize","serializedFactory","parse","saveNode","idx","MAX_IMAGE_SIZE","FactoryMap","instructions","innerSVG","height","start_x","start_y","x","y","max_x","max_y","section_i","maxInputWidth","elements","instruction_i","instruction","translate","transform","render","max","nextInstruction","endSection","endFactory","sectionWidth","section","fill","fontSize","FONTSIZE","fontWeight","dominantBaseline","textAnchor","dy","header1","header2","markerWidth","markerHeight","refX","refY","orient","points","generateInnerSVG","canvas","document","createElement","scaleWidth","scaleHeight","ctx","getContext","svg","xmlns","backgroundColor","svgBlob","Blob","renderToStaticMarkup","DOMURL","window","URL","webkitURL","svgURL","createObjectURL","img","Image","drawImage","revokeObjectURL","imgURI","toDataURL","link","download","body","appendChild","click","remove","triggerPNGDownload","encodeURIComponent","border","innerWidth","innerHeight","defaultTool","VisualizationState","CATEGORY_ORDER","STRUCTURAL_PART","EXCEPTIONAL_PART","FUNCTIONAL_PART","WARP_CELLS","AMMO","COMBAT_ELEMENT","FURNITURE_AND_APPLIANCES_ELEMENT","INDUSTRY_AND_INFRASTRUCTURE_ELEMENT","PILOTING_ELEMENT","PLANET_ELEMENT","SYSTEMS_ELEMENT","TIER_ORDER","BASIC","UNCOMMON","ADVANCED","RARE","EXOTIC","INDUSTRYLABELS","TIERLABELS","CONTAINERLABELS","SIZE","LINKSPACING","containerLabel","labels","containerCount","join","FactoryVisualization","setFactory","startingFactory","orePrices","visualizationState","setVisualizationState","showLegend","setShowLegend","scrollTo","content","industryCount","totalIndustries","totalContainers","schematicCount","oreValues","containerSize","index","industryColumns","dataIndex","industryData","count","containerColumns","containerData","schematicColumns","schematicData","schematic","oreValueColumns","round","placement","trigger","isNaN","oreValueData","INSTRUCTIONS","MAP","gutter","span","columns","dataSource","pagination","LIST","FactoryInstructions","step","setStep","TransferContainerInstruction","highlightDiff","maxOutputWidth","sortName","relayHeight","producer_i","input_i","x1","y1","x2","y2","stroke","strokeWidth","markerEnd","outputs","output_i","NodeInstruction","dumpGroup","producerHeight","dumpStart_y","relayStart_y","lastDump_y","dumpHeight","cx","cy","r","unit","numByproductConsumers","strokeDasharray","dump_y","MergedNodeInstruction","OreInstruction","replaceSizeInName","aName","bName","localeCompare","numeric","FactoryCount","className","numIndustries","getProductionRate","MemorizedFactoryCountRow","getMaintainValue","newFactory","getRequirements","setFactoryInstructions","showDifferences","dumpGroups","skip","generateInstructions","RENDER","e","ERROR","setErrorMessage","message","marginBottom","oldProps","newProps","Factory","factoryState","startFactoryState","errorMessage","factoryInstructions","productionRate","maintainValue","setShowDifferences","setStartingFactory","ExistingFactorySummary","UPLOAD","factoryJSON","uploadedFactory","uploadedFactoryCopy","SELECT","TALENT_GROUPS","parseTalentLevelJSON","json","setTalentLevels","group","MemorizedSetTalentsRow","label","_","SkillGroup","selected","setSelected","MinusOutlined","PlusOutlined","TalentGroupComp","SetTalents","uploaded","setUploaded","localStorage","setItem","setTalentState","TalentState","SET","parseOrePricesJSON","setOrePrices","price","SetOrePrices","MemorizedSetOrePricesRow","setOrePricesState","OrePricesState","rootElement","getElementById","appState","talentState","UNSET","orePricesState","getItem","SETTALENTS","SETOREPRICES","NEWFACTORY","OLDFACTORY","INFO","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","loaded","__webpack_modules__","m","O","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","splice","n","getter","__esModule","d","definition","o","defineProperty","enumerable","g","globalThis","Function","obj","prototype","hasOwnProperty","call","Symbol","toStringTag","nmd","paths","p","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","chunkLoadingGlobal","self","forEach","bind","__webpack_exports__"],"sourceRoot":""}